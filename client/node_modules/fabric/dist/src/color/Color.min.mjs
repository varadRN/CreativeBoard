import{defineProperty as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{normalizeWs as r}from"../util/internals/normalizeWhiteSpace.min.mjs";import{radiansToDegrees as e}from"../util/misc/radiansDegreesConversion.min.mjs";import{ColorNameMap as o}from"./color_map.min.mjs";import{reRGBa as s,reHSLa as c,reHex as n}from"./constants.min.mjs";import{rgb2Hsl as i,hexify as a,greyAverage as u,fromAlphaToFloat as m,hue2rgb as l}from"./util.min.mjs";class h{constructor(r){if(t(this,"isUnrecognised",!1),r)if(r instanceof h)this.setSource([...r._source]);else if(Array.isArray(r)){const[t,e,o,s=1]=r;this.setSource([t,e,o,s])}else this.setSource(this._tryParsingColor(r));else this.setSource([0,0,0,1])}_tryParsingColor(t){return(t=t.toLowerCase())in o&&(t=o[t]),"transparent"===t?[255,255,255,0]:h.sourceFromHex(t)||h.sourceFromRgb(t)||h.sourceFromHsl(t)||(this.isUnrecognised=!0)&&[0,0,0,1]}getSource(){return this._source}setSource(t){this._source=t}toRgb(){const[t,r,e]=this.getSource();return"rgb(".concat(t,",").concat(r,",").concat(e,")")}toRgba(){return"rgba(".concat(this.getSource().join(","),")")}toHsl(){const[t,r,e]=i(...this.getSource());return"hsl(".concat(t,",").concat(r,"%,").concat(e,"%)")}toHsla(){const[t,r,e,o]=i(...this.getSource());return"hsla(".concat(t,",").concat(r,"%,").concat(e,"%,").concat(o,")")}toHex(){return this.toHexa().slice(0,6)}toHexa(){const[t,r,e,o]=this.getSource();return"".concat(a(t)).concat(a(r)).concat(a(e)).concat(a(Math.round(255*o)))}getAlpha(){return this.getSource()[3]}setAlpha(t){return this._source[3]=t,this}toGrayscale(){return this.setSource(u(this.getSource())),this}toBlackWhite(t){const[r,,,e]=u(this.getSource()),o=r<(t||127)?0:255;return this.setSource([o,o,o,e]),this}overlayWith(t){t instanceof h||(t=new h(t));const r=this.getSource(),e=t.getSource(),[o,s,c]=r.map(((t,r)=>Math.round(.5*t+.5*e[r])));return this.setSource([o,s,c,r[3]]),this}static fromRgb(t){return h.fromRgba(t)}static fromRgba(t){return new h(h.sourceFromRgb(t))}static sourceFromRgb(t){const e=r(t).match(s());if(e){const[t,r,o]=e.slice(1,4).map((t=>{const r=parseFloat(t);return t.endsWith("%")?Math.round(2.55*r):r}));return[t,r,o,m(e[4])]}}static fromHsl(t){return h.fromHsla(t)}static fromHsla(t){return new h(h.sourceFromHsl(t))}static sourceFromHsl(t){const e=r(t).match(c());if(!e)return;const o=(h.parseAngletoDegrees(e[1])%360+360)%360/360,s=parseFloat(e[2])/100,n=parseFloat(e[3])/100;let i,a,u;if(0===s)i=a=u=n;else{const t=n<=.5?n*(s+1):n+s-n*s,r=2*n-t;i=l(r,t,o+1/3),a=l(r,t,o),u=l(r,t,o-1/3)}return[Math.round(255*i),Math.round(255*a),Math.round(255*u),m(e[4])]}static fromHex(t){return new h(h.sourceFromHex(t))}static sourceFromHex(t){if(t.match(n())){const r=t.slice(t.indexOf("#")+1);let e;e=r.length<=4?r.split("").map((t=>t+t)):r.match(/.{2}/g);const[o,s,c,n=255]=e.map((t=>parseInt(t,16)));return[o,s,c,n/255]}}static parseAngletoDegrees(t){const r=t.toLowerCase(),o=parseFloat(r);return r.includes("rad")?e(o):r.includes("turn")?360*o:o}}export{h as Color};
//# sourceMappingURL=Color.min.mjs.map
