{"version":3,"file":"Text.mjs","sources":["../../../../src/shapes/Text/Text.ts"],"sourcesContent":["import { cache } from '../../cache';\nimport { DEFAULT_SVG_FONT_SIZE, FILL, STROKE } from '../../constants';\nimport type { ObjectEvents } from '../../EventTypeDefs';\nimport type {\n  CompleteTextStyleDeclaration,\n  TextStyle,\n  TextStyleDeclaration,\n} from './StyledText';\nimport { StyledText } from './StyledText';\nimport { SHARED_ATTRIBUTES } from '../../parser/attributes';\nimport { parseAttributes } from '../../parser/parseAttributes';\nimport type {\n  Abortable,\n  TCacheCanvasDimensions,\n  TClassProperties,\n  TFiller,\n  TOptions,\n} from '../../typedefs';\nimport { classRegistry } from '../../ClassRegistry';\nimport { graphemeSplit } from '../../util/lang_string';\nimport { createCanvasElementFor } from '../../util/misc/dom';\nimport type { TextStyleArray } from '../../util/misc/textStyles';\nimport {\n  hasStyleChanged,\n  stylesFromArray,\n  stylesToArray,\n} from '../../util/misc/textStyles';\nimport { getPathSegmentsInfo, getPointOnPath } from '../../util/path';\nimport { cacheProperties } from '../Object/FabricObject';\nimport type { Path } from '../Path';\nimport { TextSVGExportMixin } from './TextSVGExportMixin';\nimport { applyMixins } from '../../util/applyMixins';\nimport type { FabricObjectProps, SerializedObjectProps } from '../Object/types';\nimport type { StylePropertiesType } from './constants';\nimport {\n  additionalProps,\n  textDefaultValues,\n  textLayoutProperties,\n  JUSTIFY,\n  JUSTIFY_CENTER,\n  JUSTIFY_LEFT,\n  JUSTIFY_RIGHT,\n  TEXT_DECORATION_THICKNESS,\n} from './constants';\nimport { CENTER, LEFT, RIGHT, TOP, BOTTOM } from '../../constants';\nimport { isFiller } from '../../util/typeAssertions';\nimport type { Gradient } from '../../gradient/Gradient';\nimport type { Pattern } from '../../Pattern';\nimport type { CSSRules } from '../../parser/typedefs';\nimport { normalizeWs } from '../../util/internals/normalizeWhiteSpace';\n\nlet measuringContext: CanvasRenderingContext2D | null;\n\n/**\n * Return a context for measurement of text string.\n * if created it gets stored for reuse\n */\nfunction getMeasuringContext() {\n  if (!measuringContext) {\n    const canvas = createCanvasElementFor({\n      width: 0,\n      height: 0,\n    });\n    measuringContext = canvas.getContext('2d');\n  }\n  return measuringContext;\n}\n\nexport type TPathSide = 'left' | 'right';\n\nexport type TPathAlign = 'baseline' | 'center' | 'ascender' | 'descender';\n\nexport type TextLinesInfo = {\n  lines: string[];\n  graphemeLines: string[][];\n  graphemeText: string[];\n  _unwrappedLines: string[][];\n};\n\n/**\n * Measure and return the info of a single grapheme.\n * needs the the info of previous graphemes already filled\n * Override to customize measuring\n */\nexport type GraphemeBBox = {\n  width: number;\n  height: number;\n  kernedWidth: number;\n  left: number;\n  deltaY: number;\n  renderLeft?: number;\n  renderTop?: number;\n  angle?: number;\n};\n\n// @TODO this is not complete\ninterface UniqueTextProps {\n  charSpacing: number;\n  lineHeight: number;\n  fontSize: number;\n  fontWeight: string | number;\n  fontFamily: string;\n  fontStyle: string;\n  pathSide: TPathSide;\n  pathAlign: TPathAlign;\n  underline: boolean;\n  overline: boolean;\n  linethrough: boolean;\n  textAlign: string;\n  direction: CanvasDirection;\n  path?: Path;\n  textDecorationThickness: number;\n}\n\nexport interface SerializedTextProps\n  extends SerializedObjectProps,\n    UniqueTextProps {\n  styles: TextStyleArray | TextStyle;\n}\n\nexport interface TextProps extends FabricObjectProps, UniqueTextProps {\n  styles: TextStyle;\n}\n\n/**\n * Text class\n * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}\n */\nexport class FabricText<\n    Props extends TOptions<TextProps> = Partial<TextProps>,\n    SProps extends SerializedTextProps = SerializedTextProps,\n    EventSpec extends ObjectEvents = ObjectEvents,\n  >\n  extends StyledText<Props, SProps, EventSpec>\n  implements UniqueTextProps\n{\n  /**\n   * Properties that requires a text layout recalculation when changed\n   * @type string[]\n   * @protected\n   */\n  static textLayoutProperties: string[] = textLayoutProperties;\n\n  /**\n   * @private\n   */\n  declare _reNewline: RegExp;\n\n  /**\n   * Use this regular expression to filter for whitespaces that is not a new line.\n   * Mostly used when text is 'justify' aligned.\n   * @private\n   */\n  declare _reSpacesAndTabs: RegExp;\n\n  /**\n   * Use this regular expression to filter for whitespace that is not a new line.\n   * Mostly used when text is 'justify' aligned.\n   * @private\n   */\n  declare _reSpaceAndTab: RegExp;\n\n  /**\n   * Use this regular expression to filter consecutive groups of non spaces.\n   * Mostly used when text is 'justify' aligned.\n   * @private\n   */\n  declare _reWords: RegExp;\n\n  declare text: string;\n\n  /**\n   * Font size (in pixels)\n   * @type Number\n   * @default\n   */\n  declare fontSize: number;\n\n  /**\n   * Font weight (e.g. bold, normal, 400, 600, 800)\n   * @type {(Number|String)}\n   * @default\n   */\n  declare fontWeight: string | number;\n\n  /**\n   * Font family\n   * @type String\n   * @default\n   */\n  declare fontFamily: string;\n\n  /**\n   * Text decoration underline.\n   * @type Boolean\n   * @default\n   */\n  declare underline: boolean;\n\n  /**\n   * Text decoration overline.\n   * @type Boolean\n   * @default\n   */\n  declare overline: boolean;\n\n  /**\n   * Text decoration linethrough.\n   * @type Boolean\n   * @default\n   */\n  declare linethrough: boolean;\n\n  /**\n   * Text alignment. Possible values: \"left\", \"center\", \"right\", \"justify\",\n   * \"justify-left\", \"justify-center\" or \"justify-right\".\n   * @type String\n   * @default\n   */\n  declare textAlign: string;\n\n  /**\n   * Font style . Possible values: \"\", \"normal\", \"italic\" or \"oblique\".\n   * @type String\n   * @default\n   */\n  declare fontStyle: string;\n\n  /**\n   * Line height\n   * @type Number\n   * @default\n   */\n  declare lineHeight: number;\n\n  /**\n   * Superscript schema object (minimum overlap)\n   */\n  declare superscript: {\n    /**\n     * fontSize factor\n     * @default 0.6\n     */\n    size: number;\n    /**\n     * baseline-shift factor (upwards)\n     * @default -0.35\n     */\n    baseline: number;\n  };\n\n  /**\n   * Subscript schema object (minimum overlap)\n   */\n  declare subscript: {\n    /**\n     * fontSize factor\n     * @default 0.6\n     */\n    size: number;\n    /**\n     * baseline-shift factor (downwards)\n     * @default 0.11\n     */\n    baseline: number;\n  };\n\n  /**\n   * Background color of text lines\n   * @type String\n   * @default\n   */\n  declare textBackgroundColor: string;\n\n  declare styles: TextStyle;\n\n  /**\n   * Path that the text should follow.\n   * since 4.6.0 the path will be drawn automatically.\n   * if you want to make the path visible, give it a stroke and strokeWidth or fill value\n   * if you want it to be hidden, assign visible = false to the path.\n   * This feature is in BETA, and SVG import/export is not yet supported.\n   * @type Path\n   * @example\n   * const textPath = new Text('Text on a path', {\n   *     top: 150,\n   *     left: 150,\n   *     textAlign: 'center',\n   *     charSpacing: -50,\n   *     path: new Path('M 0 0 C 50 -100 150 -100 200 0', {\n   *         strokeWidth: 1,\n   *         visible: false\n   *     }),\n   *     pathSide: 'left',\n   *     pathStartOffset: 0\n   * });\n   * @default\n   */\n  declare path?: Path;\n\n  /**\n   * The text decoration tickness for underline, overline and strikethrough\n   * The tickness is expressed in thousandths of fontSize ( em ).\n   * The original value was 1/15 that translates to 66.6667 thousandths.\n   * The choice of unit of measure is to align with charSpacing.\n   * You can slim the tickness without issues, while large underline or overline may end up\n   * outside the bounding box of the text. In order to fix that a bigger refactor of the code\n   * is needed and is out of scope for now. If you need such large overline on the first line\n   * of text or large underline on the last line of text, consider disabling caching as a\n   * workaround\n   * @default 66.667\n   */\n  declare textDecorationThickness: number;\n\n  /**\n   * Offset amount for text path starting position\n   * Only used when text has a path\n   * @default\n   */\n  declare pathStartOffset: number;\n\n  /**\n   * Which side of the path the text should be drawn on.\n   * Only used when text has a path\n   * @type {TPathSide} 'left|right'\n   * @default\n   */\n  declare pathSide: TPathSide;\n\n  /**\n   * How text is aligned to the path. This property determines\n   * the perpendicular position of each character relative to the path.\n   * (one of \"baseline\", \"center\", \"ascender\", \"descender\")\n   * This feature is in BETA, and its behavior may change\n   * @type TPathAlign\n   * @default\n   */\n  declare pathAlign: TPathAlign;\n\n  /**\n   * @private\n   */\n  declare _fontSizeFraction: number;\n\n  /**\n   * @private\n   */\n  declare offsets: { underline: number; linethrough: number; overline: number };\n\n  /**\n   * Text Line proportion to font Size (in pixels)\n   * @type Number\n   * @default\n   */\n  declare _fontSizeMult: number;\n\n  /**\n   * additional space between characters\n   * expressed in thousands of em unit\n   * @type Number\n   * @default\n   */\n  declare charSpacing: number;\n\n  /**\n   * Baseline shift, styles only, keep at 0 for the main text object\n   * @type {Number}\n   * @default\n   */\n  declare deltaY: number;\n\n  /**\n   * WARNING: EXPERIMENTAL. NOT SUPPORTED YET\n   * determine the direction of the text.\n   * This has to be set manually together with textAlign and originX for proper\n   * experience.\n   * some interesting link for the future\n   * https://www.w3.org/International/questions/qa-bidi-unicode-controls\n   * @since 4.5.0\n   * @type {CanvasDirection} 'ltr|rtl'\n   * @default\n   */\n  declare direction: CanvasDirection;\n\n  /**\n   * contains characters bounding boxes\n   * This variable is considered to be protected.\n   * But for how mixins are implemented right now, we can't leave it private\n   * @protected\n   */\n  __charBounds: GraphemeBBox[][] = [];\n\n  /**\n   * use this size when measuring text. To avoid IE11 rounding errors\n   * @type {Number}\n   * @default\n   * @readonly\n   * @private\n   */\n  declare CACHE_FONT_SIZE: number;\n\n  /**\n   * contains the min text width to avoid getting 0\n   * @type {Number}\n   * @default\n   */\n  declare MIN_TEXT_WIDTH: number;\n\n  /**\n   * contains the the text of the object, divided in lines as they are displayed\n   * on screen. Wrapping will divide the text independently of line breaks\n   * @type {string[]}\n   * @default\n   */\n  declare textLines: string[];\n\n  /**\n   * same as textlines, but each line is an array of graphemes as split by splitByGrapheme\n   * @type {string[]}\n   * @default\n   */\n  declare _textLines: string[][];\n\n  declare _unwrappedTextLines: string[][];\n  declare _text: string[];\n  declare cursorWidth: number;\n  declare __lineHeights: number[];\n  declare __lineWidths: number[];\n  declare initialized?: true;\n\n  static cacheProperties = [...cacheProperties, ...additionalProps];\n\n  static ownDefaults = textDefaultValues;\n\n  static type = 'Text';\n\n  static getDefaults(): Record<string, any> {\n    return { ...super.getDefaults(), ...FabricText.ownDefaults };\n  }\n\n  constructor(text: string, options?: Props) {\n    super();\n    Object.assign(this, FabricText.ownDefaults);\n    this.setOptions(options);\n    if (!this.styles) {\n      this.styles = {};\n    }\n    this.text = text;\n    this.initialized = true;\n    if (this.path) {\n      this.setPathInfo();\n    }\n    this.initDimensions();\n    this.setCoords();\n  }\n\n  /**\n   * If text has a path, it will add the extra information needed\n   * for path and text calculations\n   */\n  setPathInfo() {\n    const path = this.path;\n    if (path) {\n      path.segmentsInfo = getPathSegmentsInfo(path.path);\n    }\n  }\n\n  /**\n   * @private\n   * Divides text into lines of text and lines of graphemes.\n   */\n  _splitText(): TextLinesInfo {\n    const newLines = this._splitTextIntoLines(this.text);\n    this.textLines = newLines.lines;\n    this._textLines = newLines.graphemeLines;\n    this._unwrappedTextLines = newLines._unwrappedLines;\n    this._text = newLines.graphemeText;\n    return newLines;\n  }\n\n  /**\n   * Initialize or update text dimensions.\n   * Updates this.width and this.height with the proper values.\n   * Does not return dimensions.\n   */\n  initDimensions() {\n    this._splitText();\n    this._clearCache();\n    this.dirty = true;\n    if (this.path) {\n      this.width = this.path.width;\n      this.height = this.path.height;\n    } else {\n      this.width =\n        this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;\n      this.height = this.calcTextHeight();\n    }\n    if (this.textAlign.includes(JUSTIFY)) {\n      // once text is measured we need to make space fatter to make justified text.\n      this.enlargeSpaces();\n    }\n  }\n\n  /**\n   * Enlarge space boxes and shift the others\n   */\n  enlargeSpaces() {\n    let diffSpace,\n      currentLineWidth,\n      numberOfSpaces,\n      accumulatedSpace,\n      line,\n      charBound,\n      spaces;\n    for (let i = 0, len = this._textLines.length; i < len; i++) {\n      if (\n        this.textAlign !== JUSTIFY &&\n        (i === len - 1 || this.isEndOfWrapping(i))\n      ) {\n        continue;\n      }\n      accumulatedSpace = 0;\n      line = this._textLines[i];\n      currentLineWidth = this.getLineWidth(i);\n      if (\n        currentLineWidth < this.width &&\n        (spaces = this.textLines[i].match(this._reSpacesAndTabs))\n      ) {\n        numberOfSpaces = spaces.length;\n        diffSpace = (this.width - currentLineWidth) / numberOfSpaces;\n        for (let j = 0; j <= line.length; j++) {\n          charBound = this.__charBounds[i][j];\n          if (this._reSpaceAndTab.test(line[j])) {\n            charBound.width += diffSpace;\n            charBound.kernedWidth += diffSpace;\n            charBound.left += accumulatedSpace;\n            accumulatedSpace += diffSpace;\n          } else {\n            charBound.left += accumulatedSpace;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Detect if the text line is ended with an hard break\n   * text and itext do not have wrapping, return false\n   * @return {Boolean}\n   */\n  isEndOfWrapping(lineIndex: number): boolean {\n    return lineIndex === this._textLines.length - 1;\n  }\n\n  /**\n   * Detect if a line has a linebreak and so we need to account for it when moving\n   * and counting style.\n   * It return always 1 for text and Itext. Textbox has its own implementation\n   * @return Number\n   */\n  missingNewlineOffset(lineIndex: number, skipWrapping?: boolean): 0 | 1;\n  missingNewlineOffset(_lineIndex: number): 1 {\n    return 1;\n  }\n\n  /**\n   * Returns 2d representation (lineIndex and charIndex) of cursor\n   * @param {Number} selectionStart\n   * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.\n   */\n  get2DCursorLocation(selectionStart: number, skipWrapping?: boolean) {\n    const lines = skipWrapping ? this._unwrappedTextLines : this._textLines;\n    let i: number;\n    for (i = 0; i < lines.length; i++) {\n      if (selectionStart <= lines[i].length) {\n        return {\n          lineIndex: i,\n          charIndex: selectionStart,\n        };\n      }\n      selectionStart -=\n        lines[i].length + this.missingNewlineOffset(i, skipWrapping);\n    }\n    return {\n      lineIndex: i - 1,\n      charIndex:\n        lines[i - 1].length < selectionStart\n          ? lines[i - 1].length\n          : selectionStart,\n    };\n  }\n\n  /**\n   * Returns string representation of an instance\n   * @return {String} String representation of text object\n   */\n  toString(): string {\n    return `#<Text (${this.complexity()}): { \"text\": \"${\n      this.text\n    }\", \"fontFamily\": \"${this.fontFamily}\" }>`;\n  }\n\n  /**\n   * Return the dimension and the zoom level needed to create a cache canvas\n   * big enough to host the object to be cached.\n   * @private\n   * @param {Object} dim.x width of object to be cached\n   * @param {Object} dim.y height of object to be cached\n   * @return {Object}.width width of canvas\n   * @return {Object}.height height of canvas\n   * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n   * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n   */\n  _getCacheCanvasDimensions(): TCacheCanvasDimensions {\n    const dims = super._getCacheCanvasDimensions();\n    const fontSize = this.fontSize;\n    dims.width += fontSize * dims.zoomX;\n    dims.height += fontSize * dims.zoomY;\n    return dims;\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _render(ctx: CanvasRenderingContext2D) {\n    const path = this.path;\n    path && !path.isNotVisible() && path._render(ctx);\n    this._setTextStyles(ctx);\n    this._renderTextLinesBackground(ctx);\n    this._renderTextDecoration(ctx, 'underline');\n    this._renderText(ctx);\n    this._renderTextDecoration(ctx, 'overline');\n    this._renderTextDecoration(ctx, 'linethrough');\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _renderText(ctx: CanvasRenderingContext2D) {\n    if (this.paintFirst === STROKE) {\n      this._renderTextStroke(ctx);\n      this._renderTextFill(ctx);\n    } else {\n      this._renderTextFill(ctx);\n      this._renderTextStroke(ctx);\n    }\n  }\n\n  /**\n   * Set the font parameter of the context with the object properties or with charStyle\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @param {Object} [charStyle] object with font style properties\n   * @param {String} [charStyle.fontFamily] Font Family\n   * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )\n   * @param {String} [charStyle.fontWeight] Font weight\n   * @param {String} [charStyle.fontStyle] Font style (italic|normal)\n   */\n  _setTextStyles(\n    ctx: CanvasRenderingContext2D,\n    charStyle?: any,\n    forMeasuring?: boolean,\n  ) {\n    ctx.textBaseline = 'alphabetic';\n    if (this.path) {\n      switch (this.pathAlign) {\n        case CENTER:\n          ctx.textBaseline = 'middle';\n          break;\n        case 'ascender':\n          ctx.textBaseline = TOP;\n          break;\n        case 'descender':\n          ctx.textBaseline = BOTTOM;\n          break;\n      }\n    }\n    ctx.font = this._getFontDeclaration(charStyle, forMeasuring);\n  }\n\n  /**\n   * calculate and return the text Width measuring each line.\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @return {Number} Maximum width of Text object\n   */\n  calcTextWidth(): number {\n    let maxWidth = this.getLineWidth(0);\n\n    for (let i = 1, len = this._textLines.length; i < len; i++) {\n      const currentLineWidth = this.getLineWidth(i);\n      if (currentLineWidth > maxWidth) {\n        maxWidth = currentLineWidth;\n      }\n    }\n    return maxWidth;\n  }\n\n  /**\n   * @private\n   * @param {String} method Method name (\"fillText\" or \"strokeText\")\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @param {String} line Text to render\n   * @param {Number} left Left position of text\n   * @param {Number} top Top position of text\n   * @param {Number} lineIndex Index of a line in a text\n   */\n  _renderTextLine(\n    method: 'fillText' | 'strokeText',\n    ctx: CanvasRenderingContext2D,\n    line: string[],\n    left: number,\n    top: number,\n    lineIndex: number,\n  ) {\n    this._renderChars(method, ctx, line, left, top, lineIndex);\n  }\n\n  /**\n   * Renders the text background for lines, taking care of style\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _renderTextLinesBackground(ctx: CanvasRenderingContext2D) {\n    if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor')) {\n      return;\n    }\n    const originalFill = ctx.fillStyle,\n      leftOffset = this._getLeftOffset();\n    let lineTopOffset = this._getTopOffset();\n\n    for (let i = 0, len = this._textLines.length; i < len; i++) {\n      const heightOfLine = this.getHeightOfLine(i);\n      if (\n        !this.textBackgroundColor &&\n        !this.styleHas('textBackgroundColor', i)\n      ) {\n        lineTopOffset += heightOfLine;\n        continue;\n      }\n      const jlen = this._textLines[i].length;\n      const lineLeftOffset = this._getLineLeftOffset(i);\n      let boxWidth = 0;\n      let boxStart = 0;\n      let drawStart;\n      let currentColor;\n      let lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');\n      const bgHeight = this.getHeightOfLineImpl(i);\n      for (let j = 0; j < jlen; j++) {\n        // at this point charbox are either standard or full with pathInfo if there is a path.\n        const charBox = this.__charBounds[i][j] as Required<GraphemeBBox>;\n        currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');\n        if (this.path) {\n          ctx.save();\n          ctx.translate(charBox.renderLeft, charBox.renderTop);\n          ctx.rotate(charBox.angle);\n          ctx.fillStyle = currentColor;\n          currentColor &&\n            ctx.fillRect(\n              -charBox.width / 2,\n              -bgHeight * (1 - this._fontSizeFraction),\n              charBox.width,\n              bgHeight,\n            );\n          ctx.restore();\n        } else if (currentColor !== lastColor) {\n          drawStart = leftOffset + lineLeftOffset + boxStart;\n          if (this.direction === 'rtl') {\n            drawStart = this.width - drawStart - boxWidth;\n          }\n          ctx.fillStyle = lastColor;\n          lastColor &&\n            ctx.fillRect(drawStart, lineTopOffset, boxWidth, bgHeight);\n          boxStart = charBox.left;\n          boxWidth = charBox.width;\n          lastColor = currentColor;\n        } else {\n          boxWidth += charBox.kernedWidth;\n        }\n      }\n      if (currentColor && !this.path) {\n        drawStart = leftOffset + lineLeftOffset + boxStart;\n        if (this.direction === 'rtl') {\n          drawStart = this.width - drawStart - boxWidth;\n        }\n        ctx.fillStyle = currentColor;\n        ctx.fillRect(drawStart, lineTopOffset, boxWidth, bgHeight);\n      }\n      lineTopOffset += heightOfLine;\n    }\n    ctx.fillStyle = originalFill;\n    // if there is text background color no\n    // other shadows should be casted\n    this._removeShadow(ctx);\n  }\n\n  /**\n   * measure and return the width of a single character.\n   * possibly overridden to accommodate different measure logic or\n   * to hook some external lib for character measurement\n   * @private\n   * @param {String} _char, char to be measured\n   * @param {Object} charStyle style of char to be measured\n   * @param {String} [previousChar] previous char\n   * @param {Object} [prevCharStyle] style of previous char\n   */\n  _measureChar(\n    _char: string,\n    charStyle: CompleteTextStyleDeclaration,\n    previousChar: string | undefined,\n    prevCharStyle: CompleteTextStyleDeclaration | Record<string, never>,\n  ) {\n    const fontCache = cache.getFontCache(charStyle),\n      fontDeclaration = this._getFontDeclaration(charStyle),\n      couple = previousChar ? previousChar + _char : _char,\n      stylesAreEqual =\n        previousChar &&\n        fontDeclaration === this._getFontDeclaration(prevCharStyle),\n      fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE;\n    let width: number | undefined,\n      coupleWidth: number | undefined,\n      previousWidth: number | undefined,\n      kernedWidth: number | undefined;\n\n    if (previousChar && fontCache.has(previousChar)) {\n      previousWidth = fontCache.get(previousChar);\n    }\n    if (fontCache.has(_char)) {\n      kernedWidth = width = fontCache.get(_char);\n    }\n    if (stylesAreEqual && fontCache.has(couple)) {\n      coupleWidth = fontCache.get(couple)!;\n      kernedWidth = coupleWidth - previousWidth!;\n    }\n    if (\n      width === undefined ||\n      previousWidth === undefined ||\n      coupleWidth === undefined\n    ) {\n      const ctx = getMeasuringContext()!;\n      // send a TRUE to specify measuring font size CACHE_FONT_SIZE\n      this._setTextStyles(ctx, charStyle, true);\n      if (width === undefined) {\n        kernedWidth = width = ctx.measureText(_char).width;\n        fontCache.set(_char, width);\n      }\n      if (previousWidth === undefined && stylesAreEqual && previousChar) {\n        previousWidth = ctx.measureText(previousChar).width;\n        fontCache.set(previousChar, previousWidth);\n      }\n      if (stylesAreEqual && coupleWidth === undefined) {\n        // we can measure the kerning couple and subtract the width of the previous character\n        coupleWidth = ctx.measureText(couple).width;\n        fontCache.set(couple, coupleWidth);\n        // safe to use the non-null since if undefined we defined it before.\n        kernedWidth = coupleWidth - previousWidth!;\n      }\n    }\n    return {\n      width: width * fontMultiplier,\n      kernedWidth: kernedWidth! * fontMultiplier,\n    };\n  }\n\n  /**\n   * Computes height of character at given position\n   * @param {Number} line the line index number\n   * @param {Number} _char the character index number\n   * @return {Number} fontSize of the character\n   */\n  getHeightOfChar(line: number, _char: number): number {\n    return this.getValueOfPropertyAt(line, _char, 'fontSize');\n  }\n\n  /**\n   * measure a text line measuring all characters.\n   * @param {Number} lineIndex line number\n   */\n  measureLine(lineIndex: number) {\n    const lineInfo = this._measureLine(lineIndex);\n    if (this.charSpacing !== 0) {\n      lineInfo.width -= this._getWidthOfCharSpacing();\n    }\n    if (lineInfo.width < 0) {\n      lineInfo.width = 0;\n    }\n    return lineInfo;\n  }\n\n  /**\n   * measure every grapheme of a line, populating __charBounds\n   * @param {Number} lineIndex\n   * @return {Object} object.width total width of characters\n   * @return {Object} object.numOfSpaces length of chars that match this._reSpacesAndTabs\n   */\n  _measureLine(lineIndex: number) {\n    let width = 0,\n      prevGrapheme: string | undefined,\n      graphemeInfo: GraphemeBBox | undefined;\n\n    const reverse = this.pathSide === RIGHT,\n      path = this.path,\n      line = this._textLines[lineIndex],\n      llength = line.length,\n      lineBounds = new Array<GraphemeBBox>(llength);\n\n    this.__charBounds[lineIndex] = lineBounds;\n    for (let i = 0; i < llength; i++) {\n      const grapheme = line[i];\n      graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);\n      lineBounds[i] = graphemeInfo;\n      width += graphemeInfo.kernedWidth;\n      prevGrapheme = grapheme;\n    }\n    // this latest bound box represent the last character of the line\n    // to simplify cursor handling in interactive mode.\n    lineBounds[llength] = {\n      left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,\n      width: 0,\n      kernedWidth: 0,\n      height: this.fontSize,\n      deltaY: 0,\n    } as GraphemeBBox;\n    if (path && path.segmentsInfo) {\n      let positionInPath = 0;\n      const totalPathLength =\n        path.segmentsInfo[path.segmentsInfo.length - 1].length;\n      switch (this.textAlign) {\n        case LEFT:\n          positionInPath = reverse ? totalPathLength - width : 0;\n          break;\n        case CENTER:\n          positionInPath = (totalPathLength - width) / 2;\n          break;\n        case RIGHT:\n          positionInPath = reverse ? 0 : totalPathLength - width;\n          break;\n        //todo - add support for justify\n      }\n      positionInPath += this.pathStartOffset * (reverse ? -1 : 1);\n      for (\n        let i = reverse ? llength - 1 : 0;\n        reverse ? i >= 0 : i < llength;\n        reverse ? i-- : i++\n      ) {\n        graphemeInfo = lineBounds[i];\n        if (positionInPath > totalPathLength) {\n          positionInPath %= totalPathLength;\n        } else if (positionInPath < 0) {\n          positionInPath += totalPathLength;\n        }\n        // it would probably much faster to send all the grapheme position for a line\n        // and calculate path position/angle at once.\n        this._setGraphemeOnPath(positionInPath, graphemeInfo);\n        positionInPath += graphemeInfo.kernedWidth;\n      }\n    }\n    return { width: width, numOfSpaces: 0 };\n  }\n\n  /**\n   * Calculate the angle  and the left,top position of the char that follow a path.\n   * It appends it to graphemeInfo to be reused later at rendering\n   * @private\n   * @param {Number} positionInPath to be measured\n   * @param {GraphemeBBox} graphemeInfo current grapheme box information\n   * @param {Object} startingPoint position of the point\n   */\n  _setGraphemeOnPath(positionInPath: number, graphemeInfo: GraphemeBBox) {\n    const centerPosition = positionInPath + graphemeInfo.kernedWidth / 2,\n      path = this.path!;\n\n    // we are at currentPositionOnPath. we want to know what point on the path is.\n    const info = getPointOnPath(path.path, centerPosition, path.segmentsInfo)!;\n    graphemeInfo.renderLeft = info.x - path.pathOffset.x;\n    graphemeInfo.renderTop = info.y - path.pathOffset.y;\n    graphemeInfo.angle = info.angle + (this.pathSide === RIGHT ? Math.PI : 0);\n  }\n\n  /**\n   *\n   * @param {String} grapheme to be measured\n   * @param {Number} lineIndex index of the line where the char is\n   * @param {Number} charIndex position in the line\n   * @param {String} [prevGrapheme] character preceding the one to be measured\n   * @returns {GraphemeBBox} grapheme bbox\n   */\n  _getGraphemeBox(\n    grapheme: string,\n    lineIndex: number,\n    charIndex: number,\n    prevGrapheme?: string,\n    skipLeft?: boolean,\n  ): GraphemeBBox {\n    const style = this.getCompleteStyleDeclaration(lineIndex, charIndex),\n      prevStyle = prevGrapheme\n        ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1)\n        : {},\n      info = this._measureChar(grapheme, style, prevGrapheme, prevStyle);\n    let kernedWidth = info.kernedWidth,\n      width = info.width,\n      charSpacing;\n\n    if (this.charSpacing !== 0) {\n      charSpacing = this._getWidthOfCharSpacing();\n      width += charSpacing;\n      kernedWidth += charSpacing;\n    }\n\n    const box: GraphemeBBox = {\n      width,\n      left: 0,\n      height: style.fontSize,\n      kernedWidth,\n      deltaY: style.deltaY,\n    };\n    if (charIndex > 0 && !skipLeft) {\n      const previousBox = this.__charBounds[lineIndex][charIndex - 1];\n      box.left =\n        previousBox.left + previousBox.width + info.kernedWidth - info.width;\n    }\n    return box;\n  }\n\n  /**\n   * Calculate height of line at 'lineIndex',\n   * without the lineHeigth multiplication factor\n   * @private\n   * @param {Number} lineIndex index of line to calculate\n   * @return {Number}\n   */\n  private getHeightOfLineImpl(lineIndex: number): number {\n    const lh = this.__lineHeights;\n    if (lh[lineIndex]) {\n      return lh[lineIndex];\n    }\n\n    // char 0 is measured before the line cycle because it needs to char\n    // emptylines\n    let maxHeight = this.getHeightOfChar(lineIndex, 0);\n    for (let i = 1, len = this._textLines[lineIndex].length; i < len; i++) {\n      maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);\n    }\n\n    return (lh[lineIndex] = maxHeight * this._fontSizeMult);\n  }\n\n  /**\n   * Calculate height of line at 'lineIndex'\n   * @param {Number} lineIndex index of line to calculate\n   * @return {Number}\n   */\n  getHeightOfLine(lineIndex: number): number {\n    return this.getHeightOfLineImpl(lineIndex) * this.lineHeight;\n  }\n\n  /**\n   * Calculate text box height\n   */\n  calcTextHeight() {\n    let height = 0;\n    for (let i = 0, len = this._textLines.length; i < len; i++) {\n      height +=\n        i === len - 1 ? this.getHeightOfLineImpl(i) : this.getHeightOfLine(i);\n    }\n    return height;\n  }\n\n  /**\n   * @private\n   * @return {Number} Left offset\n   */\n  _getLeftOffset(): number {\n    return this.direction === 'ltr' ? -this.width / 2 : this.width / 2;\n  }\n\n  /**\n   * @private\n   * @return {Number} Top offset\n   */\n  _getTopOffset(): number {\n    return -this.height / 2;\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @param {String} method Method name (\"fillText\" or \"strokeText\")\n   */\n  _renderTextCommon(\n    ctx: CanvasRenderingContext2D,\n    method: 'fillText' | 'strokeText',\n  ) {\n    ctx.save();\n    let lineHeights = 0;\n    const left = this._getLeftOffset(),\n      top = this._getTopOffset();\n    for (let i = 0, len = this._textLines.length; i < len; i++) {\n      this._renderTextLine(\n        method,\n        ctx,\n        this._textLines[i],\n        left + this._getLineLeftOffset(i),\n        top + lineHeights + this.getHeightOfLineImpl(i),\n        i,\n      );\n      lineHeights += this.getHeightOfLine(i);\n    }\n    ctx.restore();\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _renderTextFill(ctx: CanvasRenderingContext2D) {\n    if (!this.fill && !this.styleHas(FILL)) {\n      return;\n    }\n\n    this._renderTextCommon(ctx, 'fillText');\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _renderTextStroke(ctx: CanvasRenderingContext2D) {\n    if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {\n      return;\n    }\n\n    if (this.shadow && !this.shadow.affectStroke) {\n      this._removeShadow(ctx);\n    }\n\n    ctx.save();\n    this._setLineDash(ctx, this.strokeDashArray);\n    ctx.beginPath();\n    this._renderTextCommon(ctx, 'strokeText');\n    ctx.closePath();\n    ctx.restore();\n  }\n\n  /**\n   * @private\n   * @param {String} method fillText or strokeText.\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @param {Array} line Content of the line, splitted in an array by grapheme\n   * @param {Number} left\n   * @param {Number} top\n   * @param {Number} lineIndex\n   */\n  _renderChars(\n    method: 'fillText' | 'strokeText',\n    ctx: CanvasRenderingContext2D,\n    line: Array<any>,\n    left: number,\n    top: number,\n    lineIndex: number,\n  ) {\n    const isJustify = this.textAlign.includes(JUSTIFY),\n      path = this.path,\n      shortCut =\n        !isJustify &&\n        this.charSpacing === 0 &&\n        this.isEmptyStyles(lineIndex) &&\n        !path,\n      isLtr = this.direction === 'ltr',\n      sign = this.direction === 'ltr' ? 1 : -1,\n      // this was changed in the PR #7674\n      // currentDirection = ctx.canvas.getAttribute('dir');\n      currentDirection = ctx.direction;\n\n    let actualStyle,\n      nextStyle,\n      charsToRender = '',\n      charBox,\n      boxWidth = 0,\n      timeToRender,\n      drawingLeft;\n\n    ctx.save();\n    if (currentDirection !== this.direction) {\n      ctx.canvas.setAttribute('dir', isLtr ? 'ltr' : 'rtl');\n      ctx.direction = isLtr ? 'ltr' : 'rtl';\n      ctx.textAlign = isLtr ? LEFT : RIGHT;\n    }\n    top -= this.getHeightOfLineImpl(lineIndex) * this._fontSizeFraction;\n    if (shortCut) {\n      // render all the line in one pass without checking\n      // drawingLeft = isLtr ? left : left - this.getLineWidth(lineIndex);\n      this._renderChar(method, ctx, lineIndex, 0, line.join(''), left, top);\n      ctx.restore();\n      return;\n    }\n    for (let i = 0, len = line.length - 1; i <= len; i++) {\n      timeToRender = i === len || this.charSpacing || path;\n      charsToRender += line[i];\n      charBox = this.__charBounds[lineIndex][i] as Required<GraphemeBBox>;\n      if (boxWidth === 0) {\n        left += sign * (charBox.kernedWidth - charBox.width);\n        boxWidth += charBox.width;\n      } else {\n        boxWidth += charBox.kernedWidth;\n      }\n      if (isJustify && !timeToRender) {\n        if (this._reSpaceAndTab.test(line[i])) {\n          timeToRender = true;\n        }\n      }\n      if (!timeToRender) {\n        // if we have charSpacing, we render char by char\n        actualStyle =\n          actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);\n        nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);\n        timeToRender = hasStyleChanged(actualStyle, nextStyle, false);\n      }\n      if (timeToRender) {\n        if (path) {\n          ctx.save();\n          ctx.translate(charBox.renderLeft, charBox.renderTop);\n          ctx.rotate(charBox.angle);\n          this._renderChar(\n            method,\n            ctx,\n            lineIndex,\n            i,\n            charsToRender,\n            -boxWidth / 2,\n            0,\n          );\n          ctx.restore();\n        } else {\n          drawingLeft = left;\n          this._renderChar(\n            method,\n            ctx,\n            lineIndex,\n            i,\n            charsToRender,\n            drawingLeft,\n            top,\n          );\n        }\n        charsToRender = '';\n        actualStyle = nextStyle;\n        left += sign * boxWidth;\n        boxWidth = 0;\n      }\n    }\n    ctx.restore();\n  }\n\n  /**\n   * This function try to patch the missing gradientTransform on canvas gradients.\n   * transforming a context to transform the gradient, is going to transform the stroke too.\n   * we want to transform the gradient but not the stroke operation, so we create\n   * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n   * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size\n   * is limited.\n   * @private\n   * @param {TFiller} filler a fabric gradient instance\n   * @return {CanvasPattern} a pattern to use as fill/stroke style\n   */\n  _applyPatternGradientTransformText(filler: TFiller) {\n    // TODO: verify compatibility with strokeUniform\n    const width = this.width + this.strokeWidth,\n      height = this.height + this.strokeWidth,\n      pCanvas = createCanvasElementFor({\n        width,\n        height,\n      }),\n      pCtx = pCanvas.getContext('2d')!;\n    pCanvas.width = width;\n    pCanvas.height = height;\n    pCtx.beginPath();\n    pCtx.moveTo(0, 0);\n    pCtx.lineTo(width, 0);\n    pCtx.lineTo(width, height);\n    pCtx.lineTo(0, height);\n    pCtx.closePath();\n    pCtx.translate(width / 2, height / 2);\n    pCtx.fillStyle = filler.toLive(pCtx)!;\n    this._applyPatternGradientTransform(pCtx, filler);\n    pCtx.fill();\n    return pCtx.createPattern(pCanvas, 'no-repeat')!;\n  }\n\n  handleFiller<T extends 'fill' | 'stroke'>(\n    ctx: CanvasRenderingContext2D,\n    property: `${T}Style`,\n    filler: TFiller | string,\n  ): { offsetX: number; offsetY: number } {\n    let offsetX: number, offsetY: number;\n    if (isFiller(filler)) {\n      if (\n        (filler as Gradient<'linear'>).gradientUnits === 'percentage' ||\n        (filler as Gradient<'linear'>).gradientTransform ||\n        (filler as Pattern).patternTransform\n      ) {\n        // need to transform gradient in a pattern.\n        // this is a slow process. If you are hitting this codepath, and the object\n        // is not using caching, you should consider switching it on.\n        // we need a canvas as big as the current object caching canvas.\n        offsetX = -this.width / 2;\n        offsetY = -this.height / 2;\n        ctx.translate(offsetX, offsetY);\n        ctx[property] = this._applyPatternGradientTransformText(filler);\n        return { offsetX, offsetY };\n      } else {\n        // is a simple gradient or pattern\n        ctx[property] = filler.toLive(ctx)!;\n        return this._applyPatternGradientTransform(ctx, filler);\n      }\n    } else {\n      // is a color\n      ctx[property] = filler;\n    }\n    return { offsetX: 0, offsetY: 0 };\n  }\n\n  /**\n   * This function prepare the canvas for a stroke style, and stroke and strokeWidth\n   * need to be sent in as defined\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {CompleteTextStyleDeclaration} style with stroke and strokeWidth defined\n   * @returns\n   */\n  _setStrokeStyles(\n    ctx: CanvasRenderingContext2D,\n    {\n      stroke,\n      strokeWidth,\n    }: Pick<CompleteTextStyleDeclaration, 'stroke' | 'strokeWidth'>,\n  ) {\n    ctx.lineWidth = strokeWidth;\n    ctx.lineCap = this.strokeLineCap;\n    ctx.lineDashOffset = this.strokeDashOffset;\n    ctx.lineJoin = this.strokeLineJoin;\n    ctx.miterLimit = this.strokeMiterLimit;\n    return this.handleFiller(ctx, 'strokeStyle', stroke!);\n  }\n\n  /**\n   * This function prepare the canvas for a ill style, and fill\n   * need to be sent in as defined\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {CompleteTextStyleDeclaration} style with ill defined\n   * @returns\n   */\n  _setFillStyles(ctx: CanvasRenderingContext2D, { fill }: Pick<this, 'fill'>) {\n    return this.handleFiller(ctx, 'fillStyle', fill!);\n  }\n\n  /**\n   * @private\n   * @param {String} method\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @param {String} _char\n   * @param {Number} left Left coordinate\n   * @param {Number} top Top coordinate\n   * @param {Number} lineHeight Height of the line\n   */\n  _renderChar(\n    method: 'fillText' | 'strokeText',\n    ctx: CanvasRenderingContext2D,\n    lineIndex: number,\n    charIndex: number,\n    _char: string,\n    left: number,\n    top: number,\n  ) {\n    const decl = this._getStyleDeclaration(lineIndex, charIndex),\n      fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex),\n      shouldFill = method === 'fillText' && fullDecl.fill,\n      shouldStroke =\n        method === 'strokeText' && fullDecl.stroke && fullDecl.strokeWidth;\n\n    if (!shouldStroke && !shouldFill) {\n      return;\n    }\n    ctx.save();\n\n    ctx.font = this._getFontDeclaration(fullDecl);\n\n    if (decl.textBackgroundColor) {\n      this._removeShadow(ctx);\n    }\n    if (decl.deltaY) {\n      top += decl.deltaY;\n    }\n\n    if (shouldFill) {\n      const fillOffsets = this._setFillStyles(ctx, fullDecl);\n      ctx.fillText(\n        _char,\n        left - fillOffsets.offsetX,\n        top - fillOffsets.offsetY,\n      );\n    }\n\n    if (shouldStroke) {\n      const strokeOffsets = this._setStrokeStyles(ctx, fullDecl);\n      ctx.strokeText(\n        _char,\n        left - strokeOffsets.offsetX,\n        top - strokeOffsets.offsetY,\n      );\n    }\n\n    ctx.restore();\n  }\n\n  /**\n   * Turns the character into a 'superior figure' (i.e. 'superscript')\n   * @param {Number} start selection start\n   * @param {Number} end selection end\n   */\n  setSuperscript(start: number, end: number) {\n    this._setScript(start, end, this.superscript);\n  }\n\n  /**\n   * Turns the character into an 'inferior figure' (i.e. 'subscript')\n   * @param {Number} start selection start\n   * @param {Number} end selection end\n   */\n  setSubscript(start: number, end: number) {\n    this._setScript(start, end, this.subscript);\n  }\n\n  /**\n   * Applies 'schema' at given position\n   * @private\n   * @param {Number} start selection start\n   * @param {Number} end selection end\n   * @param {Number} schema\n   */\n  protected _setScript(\n    start: number,\n    end: number,\n    schema: {\n      size: number;\n      baseline: number;\n    },\n  ) {\n    const loc = this.get2DCursorLocation(start, true),\n      fontSize = this.getValueOfPropertyAt(\n        loc.lineIndex,\n        loc.charIndex,\n        'fontSize',\n      ),\n      dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'deltaY'),\n      style = {\n        fontSize: fontSize * schema.size,\n        deltaY: dy + fontSize * schema.baseline,\n      };\n    this.setSelectionStyles(style, start, end);\n  }\n\n  /**\n   * @private\n   * @param {Number} lineIndex index text line\n   * @return {Number} Line left offset\n   */\n  _getLineLeftOffset(lineIndex: number): number {\n    const lineWidth = this.getLineWidth(lineIndex),\n      lineDiff = this.width - lineWidth,\n      textAlign = this.textAlign,\n      direction = this.direction,\n      isEndOfWrapping = this.isEndOfWrapping(lineIndex);\n    let leftOffset = 0;\n    if (\n      textAlign === JUSTIFY ||\n      (textAlign === JUSTIFY_CENTER && !isEndOfWrapping) ||\n      (textAlign === JUSTIFY_RIGHT && !isEndOfWrapping) ||\n      (textAlign === JUSTIFY_LEFT && !isEndOfWrapping)\n    ) {\n      return 0;\n    }\n    if (textAlign === CENTER) {\n      leftOffset = lineDiff / 2;\n    }\n    if (textAlign === RIGHT) {\n      leftOffset = lineDiff;\n    }\n    if (textAlign === JUSTIFY_CENTER) {\n      leftOffset = lineDiff / 2;\n    }\n    if (textAlign === JUSTIFY_RIGHT) {\n      leftOffset = lineDiff;\n    }\n    if (direction === 'rtl') {\n      if (\n        textAlign === RIGHT ||\n        textAlign === JUSTIFY ||\n        textAlign === JUSTIFY_RIGHT\n      ) {\n        leftOffset = 0;\n      } else if (textAlign === LEFT || textAlign === JUSTIFY_LEFT) {\n        leftOffset = -lineDiff;\n      } else if (textAlign === CENTER || textAlign === JUSTIFY_CENTER) {\n        leftOffset = -lineDiff / 2;\n      }\n    }\n    return leftOffset;\n  }\n\n  /**\n   * @private\n   */\n  _clearCache() {\n    this._forceClearCache = false;\n    this.__lineWidths = [];\n    this.__lineHeights = [];\n    this.__charBounds = [];\n  }\n\n  /**\n   * Measure a single line given its index. Used to calculate the initial\n   * text bounding box. The values are calculated and stored in __lineWidths cache.\n   * @private\n   * @param {Number} lineIndex line number\n   * @return {Number} Line width\n   */\n  getLineWidth(lineIndex: number): number {\n    if (this.__lineWidths[lineIndex] !== undefined) {\n      return this.__lineWidths[lineIndex];\n    }\n\n    const { width } = this.measureLine(lineIndex);\n    this.__lineWidths[lineIndex] = width;\n    return width;\n  }\n\n  _getWidthOfCharSpacing() {\n    if (this.charSpacing !== 0) {\n      return (this.fontSize * this.charSpacing) / 1000;\n    }\n    return 0;\n  }\n\n  /**\n   * Retrieves the value of property at given character position\n   * @param {Number} lineIndex the line number\n   * @param {Number} charIndex the character number\n   * @param {String} property the property name\n   * @returns the value of 'property'\n   */\n  getValueOfPropertyAt<T extends StylePropertiesType>(\n    lineIndex: number,\n    charIndex: number,\n    property: T,\n  ): this[T] {\n    const charStyle = this._getStyleDeclaration(lineIndex, charIndex);\n    return (charStyle[property] ?? this[property]) as this[T];\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _renderTextDecoration(\n    ctx: CanvasRenderingContext2D,\n    type: 'underline' | 'linethrough' | 'overline',\n  ) {\n    if (!this[type] && !this.styleHas(type)) {\n      return;\n    }\n    let topOffset = this._getTopOffset();\n    const leftOffset = this._getLeftOffset(),\n      path = this.path,\n      charSpacing = this._getWidthOfCharSpacing(),\n      offsetAligner =\n        type === 'linethrough' ? 0.5 : type === 'overline' ? 1 : 0,\n      offsetY = this.offsets[type];\n    for (let i = 0, len = this._textLines.length; i < len; i++) {\n      const heightOfLine = this.getHeightOfLine(i);\n      if (!this[type] && !this.styleHas(type, i)) {\n        topOffset += heightOfLine;\n        continue;\n      }\n      const line = this._textLines[i];\n      const maxHeight = heightOfLine / this.lineHeight;\n      const lineLeftOffset = this._getLineLeftOffset(i);\n      let boxStart = 0;\n      let boxWidth = 0;\n      let lastDecoration = this.getValueOfPropertyAt(i, 0, type);\n      let lastFill = this.getValueOfPropertyAt(i, 0, FILL);\n      let lastTickness = this.getValueOfPropertyAt(\n        i,\n        0,\n        TEXT_DECORATION_THICKNESS,\n      );\n      let currentDecoration = lastDecoration;\n      let currentFill = lastFill;\n      let currentTickness = lastTickness;\n      const top = topOffset + maxHeight * (1 - this._fontSizeFraction);\n      let size = this.getHeightOfChar(i, 0);\n      let dy = this.getValueOfPropertyAt(i, 0, 'deltaY');\n      for (let j = 0, jlen = line.length; j < jlen; j++) {\n        const charBox = this.__charBounds[i][j] as Required<GraphemeBBox>;\n        currentDecoration = this.getValueOfPropertyAt(i, j, type);\n        currentFill = this.getValueOfPropertyAt(i, j, FILL);\n        currentTickness = this.getValueOfPropertyAt(\n          i,\n          j,\n          TEXT_DECORATION_THICKNESS,\n        );\n        const currentSize = this.getHeightOfChar(i, j);\n        const currentDy = this.getValueOfPropertyAt(i, j, 'deltaY');\n        if (path && currentDecoration && currentFill) {\n          const finalTickness = (this.fontSize * currentTickness) / 1000;\n          ctx.save();\n          // bug? verify lastFill is a valid fill here.\n          ctx.fillStyle = lastFill as string;\n          ctx.translate(charBox.renderLeft, charBox.renderTop);\n          ctx.rotate(charBox.angle);\n          ctx.fillRect(\n            -charBox.kernedWidth / 2,\n            offsetY * currentSize + currentDy - offsetAligner * finalTickness,\n            charBox.kernedWidth,\n            finalTickness,\n          );\n          ctx.restore();\n        } else if (\n          (currentDecoration !== lastDecoration ||\n            currentFill !== lastFill ||\n            currentSize !== size ||\n            currentTickness !== lastTickness ||\n            currentDy !== dy) &&\n          boxWidth > 0\n        ) {\n          const finalTickness = (this.fontSize * lastTickness) / 1000;\n          let drawStart = leftOffset + lineLeftOffset + boxStart;\n          if (this.direction === 'rtl') {\n            drawStart = this.width - drawStart - boxWidth;\n          }\n          if (lastDecoration && lastFill && lastTickness) {\n            // bug? verify lastFill is a valid fill here.\n            ctx.fillStyle = lastFill as string;\n            ctx.fillRect(\n              drawStart,\n              top + offsetY * size + dy - offsetAligner * finalTickness,\n              boxWidth,\n              finalTickness,\n            );\n          }\n          boxStart = charBox.left;\n          boxWidth = charBox.width;\n          lastDecoration = currentDecoration;\n          lastTickness = currentTickness;\n          lastFill = currentFill;\n          size = currentSize;\n          dy = currentDy;\n        } else {\n          boxWidth += charBox.kernedWidth;\n        }\n      }\n      let drawStart = leftOffset + lineLeftOffset + boxStart;\n      if (this.direction === 'rtl') {\n        drawStart = this.width - drawStart - boxWidth;\n      }\n      ctx.fillStyle = currentFill as string;\n      const finalTickness = (this.fontSize * currentTickness) / 1000;\n      currentDecoration &&\n        currentFill &&\n        currentTickness &&\n        ctx.fillRect(\n          drawStart,\n          top + offsetY * size + dy - offsetAligner * finalTickness,\n          boxWidth - charSpacing,\n          finalTickness,\n        );\n      topOffset += heightOfLine;\n    }\n    // if there is text background color no\n    // other shadows should be casted\n    this._removeShadow(ctx);\n  }\n\n  /**\n   * return font declaration string for canvas context\n   * @param {Object} [styleObject] object\n   * @returns {String} font declaration formatted for canvas context.\n   */\n  _getFontDeclaration(\n    {\n      fontFamily = this.fontFamily,\n      fontStyle = this.fontStyle,\n      fontWeight = this.fontWeight,\n      fontSize = this.fontSize,\n    }: Partial<\n      Pick<\n        TextStyleDeclaration,\n        'fontFamily' | 'fontStyle' | 'fontWeight' | 'fontSize'\n      >\n    > = {},\n    forMeasuring?: boolean,\n  ): string {\n    const parsedFontFamily =\n      fontFamily.includes(\"'\") ||\n      fontFamily.includes('\"') ||\n      fontFamily.includes(',') ||\n      FabricText.genericFonts.includes(fontFamily.toLowerCase())\n        ? fontFamily\n        : `\"${fontFamily}\"`;\n    return [\n      fontStyle,\n      fontWeight,\n      `${forMeasuring ? this.CACHE_FONT_SIZE : fontSize}px`,\n      parsedFontFamily,\n    ].join(' ');\n  }\n\n  /**\n   * Renders text instance on a specified context\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  render(ctx: CanvasRenderingContext2D) {\n    if (!this.visible) {\n      return;\n    }\n    if (\n      this.canvas &&\n      this.canvas.skipOffscreen &&\n      !this.group &&\n      !this.isOnScreen()\n    ) {\n      return;\n    }\n    if (this._forceClearCache) {\n      this.initDimensions();\n    }\n    super.render(ctx);\n  }\n\n  /**\n   * Override this method to customize grapheme splitting\n   * @todo the util `graphemeSplit` needs to be injectable in some way.\n   * is more comfortable to inject the correct util rather than having to override text\n   * in the middle of the prototype chain\n   * @param {string} value\n   * @returns {string[]} array of graphemes\n   */\n  graphemeSplit(value: string): string[] {\n    return graphemeSplit(value);\n  }\n\n  /**\n   * Returns the text as an array of lines.\n   * @param {String} text text to split\n   * @returns  Lines in the text\n   */\n  _splitTextIntoLines(text: string): TextLinesInfo {\n    const lines = text.split(this._reNewline),\n      newLines = new Array<string[]>(lines.length),\n      newLine = ['\\n'];\n    let newText: string[] = [];\n    for (let i = 0; i < lines.length; i++) {\n      newLines[i] = this.graphemeSplit(lines[i]);\n      newText = newText.concat(newLines[i], newLine);\n    }\n    newText.pop();\n    return {\n      _unwrappedLines: newLines,\n      lines: lines,\n      graphemeText: newText,\n      graphemeLines: newLines,\n    };\n  }\n\n  /**\n   * Returns object representation of an instance\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} Object representation of an instance\n   */\n  toObject<\n    T extends Omit<Props & TClassProperties<this>, keyof SProps>,\n    K extends keyof T = never,\n  >(propertiesToInclude: K[] = []): Pick<T, K> & SProps {\n    return {\n      ...super.toObject([...additionalProps, ...propertiesToInclude] as K[]),\n      styles: stylesToArray(this.styles, this.text),\n      ...(this.path ? { path: this.path.toObject() } : {}),\n    };\n  }\n\n  set(key: string | any, value?: any) {\n    const { textLayoutProperties } = this.constructor as typeof FabricText;\n    super.set(key, value);\n    let needsDims = false;\n    let isAddingPath = false;\n    if (typeof key === 'object') {\n      for (const _key in key) {\n        if (_key === 'path') {\n          this.setPathInfo();\n        }\n        needsDims = needsDims || textLayoutProperties.includes(_key);\n        isAddingPath = isAddingPath || _key === 'path';\n      }\n    } else {\n      needsDims = textLayoutProperties.includes(key);\n      isAddingPath = key === 'path';\n    }\n    if (isAddingPath) {\n      this.setPathInfo();\n    }\n    if (needsDims && this.initialized) {\n      this.initDimensions();\n      this.setCoords();\n    }\n    return this;\n  }\n\n  /**\n   * Returns complexity of an instance\n   * @return {Number} complexity\n   */\n  complexity(): number {\n    return 1;\n  }\n\n  /**\n   * List of generic font families\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#generic-name\n   */\n  static genericFonts = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n    'ui-serif',\n    'ui-sans-serif',\n    'ui-monospace',\n    'ui-rounded',\n    'math',\n    'emoji',\n    'fangsong',\n  ];\n\n  /* _FROM_SVG_START_ */\n\n  /**\n   * List of attribute names to account for when parsing SVG element (used by {@link FabricText.fromElement})\n   * @static\n   * @memberOf Text\n   * @see: http://www.w3.org/TR/SVG/text.html#TextElement\n   */\n  static ATTRIBUTE_NAMES = SHARED_ATTRIBUTES.concat(\n    'x',\n    'y',\n    'dx',\n    'dy',\n    'font-family',\n    'font-style',\n    'font-weight',\n    'font-size',\n    'letter-spacing',\n    'text-decoration',\n    'text-anchor',\n  );\n\n  /**\n   * Returns FabricText instance from an SVG element (<b>not yet implemented</b>)\n   * @static\n   * @memberOf Text\n   * @param {HTMLElement} element Element to parse\n   * @param {Object} [options] Options object\n   */\n  static async fromElement(\n    element: HTMLElement,\n    options: Abortable,\n    cssRules?: CSSRules,\n  ) {\n    const parsedAttributes = parseAttributes(\n      element,\n      FabricText.ATTRIBUTE_NAMES,\n      cssRules,\n    );\n\n    const {\n      textAnchor = LEFT as typeof LEFT | typeof CENTER | typeof RIGHT,\n      textDecoration = '',\n      dx = 0,\n      dy = 0,\n      top = 0,\n      left = 0,\n      fontSize = DEFAULT_SVG_FONT_SIZE,\n      strokeWidth = 1,\n      ...restOfOptions\n    } = { ...options, ...parsedAttributes };\n\n    const textContent = normalizeWs(element.textContent || '').trim();\n\n    // this code here is probably the usual issue for SVG center find\n    // this can later looked at again and probably removed.\n\n    const text = new this(textContent, {\n        left: left + dx,\n        top: top + dy,\n        underline: textDecoration.includes('underline'),\n        overline: textDecoration.includes('overline'),\n        linethrough: textDecoration.includes('line-through'),\n        // we initialize this as 0\n        strokeWidth: 0,\n        fontSize,\n        ...restOfOptions,\n      }),\n      textHeightScaleFactor = text.getScaledHeight() / text.height,\n      lineHeightDiff =\n        (text.height + text.strokeWidth) * text.lineHeight - text.height,\n      scaledDiff = lineHeightDiff * textHeightScaleFactor,\n      textHeight = text.getScaledHeight() + scaledDiff;\n\n    let offX = 0;\n    /*\n      Adjust positioning:\n        x/y attributes in SVG correspond to the bottom-left corner of text bounding box\n        fabric output by default at top, left.\n    */\n    if (textAnchor === CENTER) {\n      offX = text.getScaledWidth() / 2;\n    }\n    if (textAnchor === RIGHT) {\n      offX = text.getScaledWidth();\n    }\n    text.set({\n      left: text.left - offX,\n      top:\n        text.top -\n        (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) /\n          text.lineHeight,\n      strokeWidth,\n    });\n    return text;\n  }\n\n  /* _FROM_SVG_END_ */\n\n  /**\n   * Returns FabricText instance from an object representation\n   * @param {Object} object plain js Object to create an instance from\n   * @returns {Promise<FabricText>}\n   */\n  static fromObject<\n    T extends TOptions<SerializedTextProps>,\n    S extends FabricText,\n  >(object: T) {\n    return this._fromObject<S>(\n      {\n        ...object,\n        styles: stylesFromArray(object.styles || {}, object.text),\n      },\n      {\n        extraParam: 'text',\n      },\n    );\n  }\n}\n\napplyMixins(FabricText, [TextSVGExportMixin]);\nclassRegistry.setClass(FabricText);\nclassRegistry.setSVGClass(FabricText);\n"],"names":["measuringContext","getMeasuringContext","canvas","createCanvasElementFor","width","height","getContext","FabricText","StyledText","getDefaults","_objectSpread","ownDefaults","constructor","text","options","_defineProperty","Object","assign","setOptions","styles","initialized","path","setPathInfo","initDimensions","setCoords","segmentsInfo","getPathSegmentsInfo","_splitText","newLines","_splitTextIntoLines","textLines","lines","_textLines","graphemeLines","_unwrappedTextLines","_unwrappedLines","_text","graphemeText","_clearCache","dirty","calcTextWidth","cursorWidth","MIN_TEXT_WIDTH","calcTextHeight","textAlign","includes","JUSTIFY","enlargeSpaces","diffSpace","currentLineWidth","numberOfSpaces","accumulatedSpace","line","charBound","spaces","i","len","length","isEndOfWrapping","getLineWidth","match","_reSpacesAndTabs","j","__charBounds","_reSpaceAndTab","test","kernedWidth","left","lineIndex","missingNewlineOffset","_lineIndex","get2DCursorLocation","selectionStart","skipWrapping","charIndex","toString","concat","complexity","fontFamily","_getCacheCanvasDimensions","dims","fontSize","zoomX","zoomY","_render","ctx","isNotVisible","_setTextStyles","_renderTextLinesBackground","_renderTextDecoration","_renderText","paintFirst","STROKE","_renderTextStroke","_renderTextFill","charStyle","forMeasuring","textBaseline","pathAlign","CENTER","TOP","BOTTOM","font","_getFontDeclaration","maxWidth","_renderTextLine","method","top","_renderChars","textBackgroundColor","styleHas","originalFill","fillStyle","leftOffset","_getLeftOffset","lineTopOffset","_getTopOffset","heightOfLine","getHeightOfLine","jlen","lineLeftOffset","_getLineLeftOffset","boxWidth","boxStart","drawStart","currentColor","lastColor","getValueOfPropertyAt","bgHeight","getHeightOfLineImpl","charBox","save","translate","renderLeft","renderTop","rotate","angle","fillRect","_fontSizeFraction","restore","direction","_removeShadow","_measureChar","_char","previousChar","prevCharStyle","fontCache","cache","getFontCache","fontDeclaration","couple","stylesAreEqual","fontMultiplier","CACHE_FONT_SIZE","coupleWidth","previousWidth","has","get","undefined","measureText","set","getHeightOfChar","measureLine","lineInfo","_measureLine","charSpacing","_getWidthOfCharSpacing","prevGrapheme","graphemeInfo","reverse","pathSide","RIGHT","llength","lineBounds","Array","grapheme","_getGraphemeBox","deltaY","positionInPath","totalPathLength","LEFT","pathStartOffset","_setGraphemeOnPath","numOfSpaces","centerPosition","info","getPointOnPath","x","pathOffset","y","Math","PI","skipLeft","style","getCompleteStyleDeclaration","prevStyle","box","previousBox","lh","__lineHeights","maxHeight","max","_fontSizeMult","lineHeight","_renderTextCommon","lineHeights","fill","FILL","stroke","strokeWidth","isEmptyStyles","shadow","affectStroke","_setLineDash","strokeDashArray","beginPath","closePath","isJustify","shortCut","isLtr","sign","currentDirection","actualStyle","nextStyle","charsToRender","timeToRender","drawingLeft","setAttribute","_renderChar","join","hasStyleChanged","_applyPatternGradientTransformText","filler","pCanvas","pCtx","moveTo","lineTo","toLive","_applyPatternGradientTransform","createPattern","handleFiller","property","offsetX","offsetY","isFiller","gradientUnits","gradientTransform","patternTransform","_setStrokeStyles","_ref","lineWidth","lineCap","strokeLineCap","lineDashOffset","strokeDashOffset","lineJoin","strokeLineJoin","miterLimit","strokeMiterLimit","_setFillStyles","_ref2","decl","_getStyleDeclaration","fullDecl","shouldFill","shouldStroke","fillOffsets","fillText","strokeOffsets","strokeText","setSuperscript","start","end","_setScript","superscript","setSubscript","subscript","schema","loc","dy","size","baseline","setSelectionStyles","lineDiff","JUSTIFY_CENTER","JUSTIFY_RIGHT","JUSTIFY_LEFT","_forceClearCache","__lineWidths","_charStyle$property","type","topOffset","offsetAligner","offsets","lastDecoration","lastFill","lastTickness","TEXT_DECORATION_THICKNESS","currentDecoration","currentFill","currentTickness","currentSize","currentDy","finalTickness","fontStyle","fontWeight","arguments","parsedFontFamily","genericFonts","toLowerCase","render","visible","skipOffscreen","group","isOnScreen","graphemeSplit","value","split","_reNewline","newLine","newText","pop","toObject","propertiesToInclude","additionalProps","stylesToArray","key","textLayoutProperties","needsDims","isAddingPath","_key","fromElement","element","cssRules","parsedAttributes","parseAttributes","ATTRIBUTE_NAMES","_options$parsedAttrib","textAnchor","textDecoration","dx","DEFAULT_SVG_FONT_SIZE","restOfOptions","_objectWithoutProperties","_excluded","textContent","normalizeWs","trim","underline","overline","linethrough","textHeightScaleFactor","getScaledHeight","lineHeightDiff","scaledDiff","textHeight","offX","getScaledWidth","fromObject","object","_fromObject","stylesFromArray","extraParam","cacheProperties","textDefaultValues","SHARED_ATTRIBUTES","applyMixins","TextSVGExportMixin","classRegistry","setClass","setSVGClass"],"mappings":";;;;;;;;;;;;;;;;;;;;AAmDA,IAAIA,gBAAiD,CAAA;;AAErD;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,GAAG;EAC7B,IAAI,CAACD,gBAAgB,EAAE;IACrB,MAAME,MAAM,GAAGC,sBAAsB,CAAC;AACpCC,MAAAA,KAAK,EAAE,CAAC;AACRC,MAAAA,MAAM,EAAE,CAAA;AACV,KAAC,CAAC,CAAA;AACFL,IAAAA,gBAAgB,GAAGE,MAAM,CAACI,UAAU,CAAC,IAAI,CAAC,CAAA;AAC5C,GAAA;AACA,EAAA,OAAON,gBAAgB,CAAA;AACzB,CAAA;;AAaA;AACA;AACA;AACA;AACA;;AAYA;;AA6BA;AACA;AACA;AACA;AACO,MAAMO,UAAU,SAKbC,UAAU,CAEpB;EA6SE,OAAOC,WAAWA,GAAwB;AACxC,IAAA,OAAAC,cAAA,CAAAA,cAAA,CAAA,EAAA,EAAY,KAAK,CAACD,WAAW,EAAE,CAAA,EAAKF,UAAU,CAACI,WAAW,CAAA,CAAA;AAC5D,GAAA;AAEAC,EAAAA,WAAWA,CAACC,IAAY,EAAEC,OAAe,EAAE;AACzC,IAAA,KAAK,EAAE,CAAA;AAzDT;AACF;AACA;AACA;AACA;AACA;AALEC,IAAAA,eAAA,uBAMiC,EAAE,CAAA,CAAA;IAoDjCC,MAAM,CAACC,MAAM,CAAC,IAAI,EAAEV,UAAU,CAACI,WAAW,CAAC,CAAA;AAC3C,IAAA,IAAI,CAACO,UAAU,CAACJ,OAAO,CAAC,CAAA;AACxB,IAAA,IAAI,CAAC,IAAI,CAACK,MAAM,EAAE;AAChB,MAAA,IAAI,CAACA,MAAM,GAAG,EAAE,CAAA;AAClB,KAAA;IACA,IAAI,CAACN,IAAI,GAAGA,IAAI,CAAA;IAChB,IAAI,CAACO,WAAW,GAAG,IAAI,CAAA;IACvB,IAAI,IAAI,CAACC,IAAI,EAAE;MACb,IAAI,CAACC,WAAW,EAAE,CAAA;AACpB,KAAA;IACA,IAAI,CAACC,cAAc,EAAE,CAAA;IACrB,IAAI,CAACC,SAAS,EAAE,CAAA;AAClB,GAAA;;AAEA;AACF;AACA;AACA;AACEF,EAAAA,WAAWA,GAAG;AACZ,IAAA,MAAMD,IAAI,GAAG,IAAI,CAACA,IAAI,CAAA;AACtB,IAAA,IAAIA,IAAI,EAAE;MACRA,IAAI,CAACI,YAAY,GAAGC,mBAAmB,CAACL,IAAI,CAACA,IAAI,CAAC,CAAA;AACpD,KAAA;AACF,GAAA;;AAEA;AACF;AACA;AACA;AACEM,EAAAA,UAAUA,GAAkB;IAC1B,MAAMC,QAAQ,GAAG,IAAI,CAACC,mBAAmB,CAAC,IAAI,CAAChB,IAAI,CAAC,CAAA;AACpD,IAAA,IAAI,CAACiB,SAAS,GAAGF,QAAQ,CAACG,KAAK,CAAA;AAC/B,IAAA,IAAI,CAACC,UAAU,GAAGJ,QAAQ,CAACK,aAAa,CAAA;AACxC,IAAA,IAAI,CAACC,mBAAmB,GAAGN,QAAQ,CAACO,eAAe,CAAA;AACnD,IAAA,IAAI,CAACC,KAAK,GAAGR,QAAQ,CAACS,YAAY,CAAA;AAClC,IAAA,OAAOT,QAAQ,CAAA;AACjB,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACEL,EAAAA,cAAcA,GAAG;IACf,IAAI,CAACI,UAAU,EAAE,CAAA;IACjB,IAAI,CAACW,WAAW,EAAE,CAAA;IAClB,IAAI,CAACC,KAAK,GAAG,IAAI,CAAA;IACjB,IAAI,IAAI,CAAClB,IAAI,EAAE;AACb,MAAA,IAAI,CAACjB,KAAK,GAAG,IAAI,CAACiB,IAAI,CAACjB,KAAK,CAAA;AAC5B,MAAA,IAAI,CAACC,MAAM,GAAG,IAAI,CAACgB,IAAI,CAAChB,MAAM,CAAA;AAChC,KAAC,MAAM;AACL,MAAA,IAAI,CAACD,KAAK,GACR,IAAI,CAACoC,aAAa,EAAE,IAAI,IAAI,CAACC,WAAW,IAAI,IAAI,CAACC,cAAc,CAAA;AACjE,MAAA,IAAI,CAACrC,MAAM,GAAG,IAAI,CAACsC,cAAc,EAAE,CAAA;AACrC,KAAA;IACA,IAAI,IAAI,CAACC,SAAS,CAACC,QAAQ,CAACC,OAAO,CAAC,EAAE;AACpC;MACA,IAAI,CAACC,aAAa,EAAE,CAAA;AACtB,KAAA;AACF,GAAA;;AAEA;AACF;AACA;AACEA,EAAAA,aAAaA,GAAG;AACd,IAAA,IAAIC,SAAS,EACXC,gBAAgB,EAChBC,cAAc,EACdC,gBAAgB,EAChBC,IAAI,EACJC,SAAS,EACTC,MAAM,CAAA;AACR,IAAA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACxB,UAAU,CAACyB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;AAC1D,MAAA,IACE,IAAI,CAACX,SAAS,KAAKE,OAAO,KACzBS,CAAC,KAAKC,GAAG,GAAG,CAAC,IAAI,IAAI,CAACE,eAAe,CAACH,CAAC,CAAC,CAAC,EAC1C;AACA,QAAA,SAAA;AACF,OAAA;AACAJ,MAAAA,gBAAgB,GAAG,CAAC,CAAA;AACpBC,MAAAA,IAAI,GAAG,IAAI,CAACpB,UAAU,CAACuB,CAAC,CAAC,CAAA;AACzBN,MAAAA,gBAAgB,GAAG,IAAI,CAACU,YAAY,CAACJ,CAAC,CAAC,CAAA;MACvC,IACEN,gBAAgB,GAAG,IAAI,CAAC7C,KAAK,KAC5BkD,MAAM,GAAG,IAAI,CAACxB,SAAS,CAACyB,CAAC,CAAC,CAACK,KAAK,CAAC,IAAI,CAACC,gBAAgB,CAAC,CAAC,EACzD;QACAX,cAAc,GAAGI,MAAM,CAACG,MAAM,CAAA;QAC9BT,SAAS,GAAG,CAAC,IAAI,CAAC5C,KAAK,GAAG6C,gBAAgB,IAAIC,cAAc,CAAA;AAC5D,QAAA,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIV,IAAI,CAACK,MAAM,EAAEK,CAAC,EAAE,EAAE;UACrCT,SAAS,GAAG,IAAI,CAACU,YAAY,CAACR,CAAC,CAAC,CAACO,CAAC,CAAC,CAAA;UACnC,IAAI,IAAI,CAACE,cAAc,CAACC,IAAI,CAACb,IAAI,CAACU,CAAC,CAAC,CAAC,EAAE;YACrCT,SAAS,CAACjD,KAAK,IAAI4C,SAAS,CAAA;YAC5BK,SAAS,CAACa,WAAW,IAAIlB,SAAS,CAAA;YAClCK,SAAS,CAACc,IAAI,IAAIhB,gBAAgB,CAAA;AAClCA,YAAAA,gBAAgB,IAAIH,SAAS,CAAA;AAC/B,WAAC,MAAM;YACLK,SAAS,CAACc,IAAI,IAAIhB,gBAAgB,CAAA;AACpC,WAAA;AACF,SAAA;AACF,OAAA;AACF,KAAA;AACF,GAAA;;AAEA;AACF;AACA;AACA;AACA;EACEO,eAAeA,CAACU,SAAiB,EAAW;IAC1C,OAAOA,SAAS,KAAK,IAAI,CAACpC,UAAU,CAACyB,MAAM,GAAG,CAAC,CAAA;AACjD,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;;EAEEY,oBAAoBA,CAACC,UAAkB,EAAK;AAC1C,IAAA,OAAO,CAAC,CAAA;AACV,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACEC,EAAAA,mBAAmBA,CAACC,cAAsB,EAAEC,YAAsB,EAAE;IAClE,MAAM1C,KAAK,GAAG0C,YAAY,GAAG,IAAI,CAACvC,mBAAmB,GAAG,IAAI,CAACF,UAAU,CAAA;AACvE,IAAA,IAAIuB,CAAS,CAAA;AACb,IAAA,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxB,KAAK,CAAC0B,MAAM,EAAEF,CAAC,EAAE,EAAE;MACjC,IAAIiB,cAAc,IAAIzC,KAAK,CAACwB,CAAC,CAAC,CAACE,MAAM,EAAE;QACrC,OAAO;AACLW,UAAAA,SAAS,EAAEb,CAAC;AACZmB,UAAAA,SAAS,EAAEF,cAAAA;SACZ,CAAA;AACH,OAAA;AACAA,MAAAA,cAAc,IACZzC,KAAK,CAACwB,CAAC,CAAC,CAACE,MAAM,GAAG,IAAI,CAACY,oBAAoB,CAACd,CAAC,EAAEkB,YAAY,CAAC,CAAA;AAChE,KAAA;IACA,OAAO;MACLL,SAAS,EAAEb,CAAC,GAAG,CAAC;MAChBmB,SAAS,EACP3C,KAAK,CAACwB,CAAC,GAAG,CAAC,CAAC,CAACE,MAAM,GAAGe,cAAc,GAChCzC,KAAK,CAACwB,CAAC,GAAG,CAAC,CAAC,CAACE,MAAM,GACnBe,cAAAA;KACP,CAAA;AACH,GAAA;;AAEA;AACF;AACA;AACA;AACEG,EAAAA,QAAQA,GAAW;AACjB,IAAA,OAAA,UAAA,CAAAC,MAAA,CAAkB,IAAI,CAACC,UAAU,EAAE,EAAAD,mBAAAA,CAAAA,CAAAA,MAAA,CACjC,IAAI,CAAC/D,IAAI,EAAA,wBAAA,CAAA,CAAA+D,MAAA,CACU,IAAI,CAACE,UAAU,EAAA,OAAA,CAAA,CAAA;AACtC,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,yBAAyBA,GAA2B;AAClD,IAAA,MAAMC,IAAI,GAAG,KAAK,CAACD,yBAAyB,EAAE,CAAA;AAC9C,IAAA,MAAME,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAA;AAC9BD,IAAAA,IAAI,CAAC5E,KAAK,IAAI6E,QAAQ,GAAGD,IAAI,CAACE,KAAK,CAAA;AACnCF,IAAAA,IAAI,CAAC3E,MAAM,IAAI4E,QAAQ,GAAGD,IAAI,CAACG,KAAK,CAAA;AACpC,IAAA,OAAOH,IAAI,CAAA;AACb,GAAA;;AAEA;AACF;AACA;AACA;EACEI,OAAOA,CAACC,GAA6B,EAAE;AACrC,IAAA,MAAMhE,IAAI,GAAG,IAAI,CAACA,IAAI,CAAA;AACtBA,IAAAA,IAAI,IAAI,CAACA,IAAI,CAACiE,YAAY,EAAE,IAAIjE,IAAI,CAAC+D,OAAO,CAACC,GAAG,CAAC,CAAA;AACjD,IAAA,IAAI,CAACE,cAAc,CAACF,GAAG,CAAC,CAAA;AACxB,IAAA,IAAI,CAACG,0BAA0B,CAACH,GAAG,CAAC,CAAA;AACpC,IAAA,IAAI,CAACI,qBAAqB,CAACJ,GAAG,EAAE,WAAW,CAAC,CAAA;AAC5C,IAAA,IAAI,CAACK,WAAW,CAACL,GAAG,CAAC,CAAA;AACrB,IAAA,IAAI,CAACI,qBAAqB,CAACJ,GAAG,EAAE,UAAU,CAAC,CAAA;AAC3C,IAAA,IAAI,CAACI,qBAAqB,CAACJ,GAAG,EAAE,aAAa,CAAC,CAAA;AAChD,GAAA;;AAEA;AACF;AACA;AACA;EACEK,WAAWA,CAACL,GAA6B,EAAE;AACzC,IAAA,IAAI,IAAI,CAACM,UAAU,KAAKC,MAAM,EAAE;AAC9B,MAAA,IAAI,CAACC,iBAAiB,CAACR,GAAG,CAAC,CAAA;AAC3B,MAAA,IAAI,CAACS,eAAe,CAACT,GAAG,CAAC,CAAA;AAC3B,KAAC,MAAM;AACL,MAAA,IAAI,CAACS,eAAe,CAACT,GAAG,CAAC,CAAA;AACzB,MAAA,IAAI,CAACQ,iBAAiB,CAACR,GAAG,CAAC,CAAA;AAC7B,KAAA;AACF,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEE,EAAAA,cAAcA,CACZF,GAA6B,EAC7BU,SAAe,EACfC,YAAsB,EACtB;IACAX,GAAG,CAACY,YAAY,GAAG,YAAY,CAAA;IAC/B,IAAI,IAAI,CAAC5E,IAAI,EAAE;MACb,QAAQ,IAAI,CAAC6E,SAAS;AACpB,QAAA,KAAKC,MAAM;UACTd,GAAG,CAACY,YAAY,GAAG,QAAQ,CAAA;AAC3B,UAAA,MAAA;AACF,QAAA,KAAK,UAAU;UACbZ,GAAG,CAACY,YAAY,GAAGG,GAAG,CAAA;AACtB,UAAA,MAAA;AACF,QAAA,KAAK,WAAW;UACdf,GAAG,CAACY,YAAY,GAAGI,MAAM,CAAA;AACzB,UAAA,MAAA;AACJ,OAAA;AACF,KAAA;IACAhB,GAAG,CAACiB,IAAI,GAAG,IAAI,CAACC,mBAAmB,CAACR,SAAS,EAAEC,YAAY,CAAC,CAAA;AAC9D,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACExD,EAAAA,aAAaA,GAAW;AACtB,IAAA,IAAIgE,QAAQ,GAAG,IAAI,CAAC7C,YAAY,CAAC,CAAC,CAAC,CAAA;AAEnC,IAAA,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACxB,UAAU,CAACyB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;AAC1D,MAAA,MAAMN,gBAAgB,GAAG,IAAI,CAACU,YAAY,CAACJ,CAAC,CAAC,CAAA;MAC7C,IAAIN,gBAAgB,GAAGuD,QAAQ,EAAE;AAC/BA,QAAAA,QAAQ,GAAGvD,gBAAgB,CAAA;AAC7B,OAAA;AACF,KAAA;AACA,IAAA,OAAOuD,QAAQ,CAAA;AACjB,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,eAAeA,CACbC,MAAiC,EACjCrB,GAA6B,EAC7BjC,IAAc,EACde,IAAY,EACZwC,GAAW,EACXvC,SAAiB,EACjB;AACA,IAAA,IAAI,CAACwC,YAAY,CAACF,MAAM,EAAErB,GAAG,EAAEjC,IAAI,EAAEe,IAAI,EAAEwC,GAAG,EAAEvC,SAAS,CAAC,CAAA;AAC5D,GAAA;;AAEA;AACF;AACA;AACA;AACA;EACEoB,0BAA0BA,CAACH,GAA6B,EAAE;AACxD,IAAA,IAAI,CAAC,IAAI,CAACwB,mBAAmB,IAAI,CAAC,IAAI,CAACC,QAAQ,CAAC,qBAAqB,CAAC,EAAE;AACtE,MAAA,OAAA;AACF,KAAA;AACA,IAAA,MAAMC,YAAY,GAAG1B,GAAG,CAAC2B,SAAS;AAChCC,MAAAA,UAAU,GAAG,IAAI,CAACC,cAAc,EAAE,CAAA;AACpC,IAAA,IAAIC,aAAa,GAAG,IAAI,CAACC,aAAa,EAAE,CAAA;AAExC,IAAA,KAAK,IAAI7D,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACxB,UAAU,CAACyB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;AAC1D,MAAA,MAAM8D,YAAY,GAAG,IAAI,CAACC,eAAe,CAAC/D,CAAC,CAAC,CAAA;AAC5C,MAAA,IACE,CAAC,IAAI,CAACsD,mBAAmB,IACzB,CAAC,IAAI,CAACC,QAAQ,CAAC,qBAAqB,EAAEvD,CAAC,CAAC,EACxC;AACA4D,QAAAA,aAAa,IAAIE,YAAY,CAAA;AAC7B,QAAA,SAAA;AACF,OAAA;MACA,MAAME,IAAI,GAAG,IAAI,CAACvF,UAAU,CAACuB,CAAC,CAAC,CAACE,MAAM,CAAA;AACtC,MAAA,MAAM+D,cAAc,GAAG,IAAI,CAACC,kBAAkB,CAAClE,CAAC,CAAC,CAAA;MACjD,IAAImE,QAAQ,GAAG,CAAC,CAAA;MAChB,IAAIC,QAAQ,GAAG,CAAC,CAAA;AAChB,MAAA,IAAIC,SAAS,CAAA;AACb,MAAA,IAAIC,YAAY,CAAA;MAChB,IAAIC,SAAS,GAAG,IAAI,CAACC,oBAAoB,CAACxE,CAAC,EAAE,CAAC,EAAE,qBAAqB,CAAC,CAAA;AACtE,MAAA,MAAMyE,QAAQ,GAAG,IAAI,CAACC,mBAAmB,CAAC1E,CAAC,CAAC,CAAA;MAC5C,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyD,IAAI,EAAEzD,CAAC,EAAE,EAAE;AAC7B;QACA,MAAMoE,OAAO,GAAG,IAAI,CAACnE,YAAY,CAACR,CAAC,CAAC,CAACO,CAAC,CAA2B,CAAA;QACjE+D,YAAY,GAAG,IAAI,CAACE,oBAAoB,CAACxE,CAAC,EAAEO,CAAC,EAAE,qBAAqB,CAAC,CAAA;QACrE,IAAI,IAAI,CAACzC,IAAI,EAAE;UACbgE,GAAG,CAAC8C,IAAI,EAAE,CAAA;UACV9C,GAAG,CAAC+C,SAAS,CAACF,OAAO,CAACG,UAAU,EAAEH,OAAO,CAACI,SAAS,CAAC,CAAA;AACpDjD,UAAAA,GAAG,CAACkD,MAAM,CAACL,OAAO,CAACM,KAAK,CAAC,CAAA;UACzBnD,GAAG,CAAC2B,SAAS,GAAGa,YAAY,CAAA;UAC5BA,YAAY,IACVxC,GAAG,CAACoD,QAAQ,CACV,CAACP,OAAO,CAAC9H,KAAK,GAAG,CAAC,EAClB,CAAC4H,QAAQ,IAAI,CAAC,GAAG,IAAI,CAACU,iBAAiB,CAAC,EACxCR,OAAO,CAAC9H,KAAK,EACb4H,QACF,CAAC,CAAA;UACH3C,GAAG,CAACsD,OAAO,EAAE,CAAA;AACf,SAAC,MAAM,IAAId,YAAY,KAAKC,SAAS,EAAE;AACrCF,UAAAA,SAAS,GAAGX,UAAU,GAAGO,cAAc,GAAGG,QAAQ,CAAA;AAClD,UAAA,IAAI,IAAI,CAACiB,SAAS,KAAK,KAAK,EAAE;AAC5BhB,YAAAA,SAAS,GAAG,IAAI,CAACxH,KAAK,GAAGwH,SAAS,GAAGF,QAAQ,CAAA;AAC/C,WAAA;UACArC,GAAG,CAAC2B,SAAS,GAAGc,SAAS,CAAA;AACzBA,UAAAA,SAAS,IACPzC,GAAG,CAACoD,QAAQ,CAACb,SAAS,EAAET,aAAa,EAAEO,QAAQ,EAAEM,QAAQ,CAAC,CAAA;UAC5DL,QAAQ,GAAGO,OAAO,CAAC/D,IAAI,CAAA;UACvBuD,QAAQ,GAAGQ,OAAO,CAAC9H,KAAK,CAAA;AACxB0H,UAAAA,SAAS,GAAGD,YAAY,CAAA;AAC1B,SAAC,MAAM;UACLH,QAAQ,IAAIQ,OAAO,CAAChE,WAAW,CAAA;AACjC,SAAA;AACF,OAAA;AACA,MAAA,IAAI2D,YAAY,IAAI,CAAC,IAAI,CAACxG,IAAI,EAAE;AAC9BuG,QAAAA,SAAS,GAAGX,UAAU,GAAGO,cAAc,GAAGG,QAAQ,CAAA;AAClD,QAAA,IAAI,IAAI,CAACiB,SAAS,KAAK,KAAK,EAAE;AAC5BhB,UAAAA,SAAS,GAAG,IAAI,CAACxH,KAAK,GAAGwH,SAAS,GAAGF,QAAQ,CAAA;AAC/C,SAAA;QACArC,GAAG,CAAC2B,SAAS,GAAGa,YAAY,CAAA;QAC5BxC,GAAG,CAACoD,QAAQ,CAACb,SAAS,EAAET,aAAa,EAAEO,QAAQ,EAAEM,QAAQ,CAAC,CAAA;AAC5D,OAAA;AACAb,MAAAA,aAAa,IAAIE,YAAY,CAAA;AAC/B,KAAA;IACAhC,GAAG,CAAC2B,SAAS,GAAGD,YAAY,CAAA;AAC5B;AACA;AACA,IAAA,IAAI,CAAC8B,aAAa,CAACxD,GAAG,CAAC,CAAA;AACzB,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEyD,YAAYA,CACVC,KAAa,EACbhD,SAAuC,EACvCiD,YAAgC,EAChCC,aAAmE,EACnE;AACA,IAAA,MAAMC,SAAS,GAAGC,KAAK,CAACC,YAAY,CAACrD,SAAS,CAAC;AAC7CsD,MAAAA,eAAe,GAAG,IAAI,CAAC9C,mBAAmB,CAACR,SAAS,CAAC;AACrDuD,MAAAA,MAAM,GAAGN,YAAY,GAAGA,YAAY,GAAGD,KAAK,GAAGA,KAAK;MACpDQ,cAAc,GACZP,YAAY,IACZK,eAAe,KAAK,IAAI,CAAC9C,mBAAmB,CAAC0C,aAAa,CAAC;AAC7DO,MAAAA,cAAc,GAAGzD,SAAS,CAACd,QAAQ,GAAG,IAAI,CAACwE,eAAe,CAAA;AAC5D,IAAA,IAAIrJ,KAAyB,EAC3BsJ,WAA+B,EAC/BC,aAAiC,EACjCzF,WAA+B,CAAA;IAEjC,IAAI8E,YAAY,IAAIE,SAAS,CAACU,GAAG,CAACZ,YAAY,CAAC,EAAE;AAC/CW,MAAAA,aAAa,GAAGT,SAAS,CAACW,GAAG,CAACb,YAAY,CAAC,CAAA;AAC7C,KAAA;AACA,IAAA,IAAIE,SAAS,CAACU,GAAG,CAACb,KAAK,CAAC,EAAE;MACxB7E,WAAW,GAAG9D,KAAK,GAAG8I,SAAS,CAACW,GAAG,CAACd,KAAK,CAAC,CAAA;AAC5C,KAAA;IACA,IAAIQ,cAAc,IAAIL,SAAS,CAACU,GAAG,CAACN,MAAM,CAAC,EAAE;AAC3CI,MAAAA,WAAW,GAAGR,SAAS,CAACW,GAAG,CAACP,MAAM,CAAE,CAAA;MACpCpF,WAAW,GAAGwF,WAAW,GAAGC,aAAc,CAAA;AAC5C,KAAA;IACA,IACEvJ,KAAK,KAAK0J,SAAS,IACnBH,aAAa,KAAKG,SAAS,IAC3BJ,WAAW,KAAKI,SAAS,EACzB;AACA,MAAA,MAAMzE,GAAG,GAAGpF,mBAAmB,EAAG,CAAA;AAClC;MACA,IAAI,CAACsF,cAAc,CAACF,GAAG,EAAEU,SAAS,EAAE,IAAI,CAAC,CAAA;MACzC,IAAI3F,KAAK,KAAK0J,SAAS,EAAE;QACvB5F,WAAW,GAAG9D,KAAK,GAAGiF,GAAG,CAAC0E,WAAW,CAAChB,KAAK,CAAC,CAAC3I,KAAK,CAAA;AAClD8I,QAAAA,SAAS,CAACc,GAAG,CAACjB,KAAK,EAAE3I,KAAK,CAAC,CAAA;AAC7B,OAAA;AACA,MAAA,IAAIuJ,aAAa,KAAKG,SAAS,IAAIP,cAAc,IAAIP,YAAY,EAAE;QACjEW,aAAa,GAAGtE,GAAG,CAAC0E,WAAW,CAACf,YAAY,CAAC,CAAC5I,KAAK,CAAA;AACnD8I,QAAAA,SAAS,CAACc,GAAG,CAAChB,YAAY,EAAEW,aAAa,CAAC,CAAA;AAC5C,OAAA;AACA,MAAA,IAAIJ,cAAc,IAAIG,WAAW,KAAKI,SAAS,EAAE;AAC/C;QACAJ,WAAW,GAAGrE,GAAG,CAAC0E,WAAW,CAACT,MAAM,CAAC,CAAClJ,KAAK,CAAA;AAC3C8I,QAAAA,SAAS,CAACc,GAAG,CAACV,MAAM,EAAEI,WAAW,CAAC,CAAA;AAClC;QACAxF,WAAW,GAAGwF,WAAW,GAAGC,aAAc,CAAA;AAC5C,OAAA;AACF,KAAA;IACA,OAAO;MACLvJ,KAAK,EAAEA,KAAK,GAAGoJ,cAAc;MAC7BtF,WAAW,EAAEA,WAAW,GAAIsF,cAAAA;KAC7B,CAAA;AACH,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACES,EAAAA,eAAeA,CAAC7G,IAAY,EAAE2F,KAAa,EAAU;IACnD,OAAO,IAAI,CAAChB,oBAAoB,CAAC3E,IAAI,EAAE2F,KAAK,EAAE,UAAU,CAAC,CAAA;AAC3D,GAAA;;AAEA;AACF;AACA;AACA;EACEmB,WAAWA,CAAC9F,SAAiB,EAAE;AAC7B,IAAA,MAAM+F,QAAQ,GAAG,IAAI,CAACC,YAAY,CAAChG,SAAS,CAAC,CAAA;AAC7C,IAAA,IAAI,IAAI,CAACiG,WAAW,KAAK,CAAC,EAAE;AAC1BF,MAAAA,QAAQ,CAAC/J,KAAK,IAAI,IAAI,CAACkK,sBAAsB,EAAE,CAAA;AACjD,KAAA;AACA,IAAA,IAAIH,QAAQ,CAAC/J,KAAK,GAAG,CAAC,EAAE;MACtB+J,QAAQ,CAAC/J,KAAK,GAAG,CAAC,CAAA;AACpB,KAAA;AACA,IAAA,OAAO+J,QAAQ,CAAA;AACjB,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;EACEC,YAAYA,CAAChG,SAAiB,EAAE;IAC9B,IAAIhE,KAAK,GAAG,CAAC;MACXmK,YAAgC;MAChCC,YAAsC,CAAA;AAExC,IAAA,MAAMC,OAAO,GAAG,IAAI,CAACC,QAAQ,KAAKC,KAAK;MACrCtJ,IAAI,GAAG,IAAI,CAACA,IAAI;AAChB+B,MAAAA,IAAI,GAAG,IAAI,CAACpB,UAAU,CAACoC,SAAS,CAAC;MACjCwG,OAAO,GAAGxH,IAAI,CAACK,MAAM;AACrBoH,MAAAA,UAAU,GAAG,IAAIC,KAAK,CAAeF,OAAO,CAAC,CAAA;AAE/C,IAAA,IAAI,CAAC7G,YAAY,CAACK,SAAS,CAAC,GAAGyG,UAAU,CAAA;IACzC,KAAK,IAAItH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqH,OAAO,EAAErH,CAAC,EAAE,EAAE;AAChC,MAAA,MAAMwH,QAAQ,GAAG3H,IAAI,CAACG,CAAC,CAAC,CAAA;AACxBiH,MAAAA,YAAY,GAAG,IAAI,CAACQ,eAAe,CAACD,QAAQ,EAAE3G,SAAS,EAAEb,CAAC,EAAEgH,YAAY,CAAC,CAAA;AACzEM,MAAAA,UAAU,CAACtH,CAAC,CAAC,GAAGiH,YAAY,CAAA;MAC5BpK,KAAK,IAAIoK,YAAY,CAACtG,WAAW,CAAA;AACjCqG,MAAAA,YAAY,GAAGQ,QAAQ,CAAA;AACzB,KAAA;AACA;AACA;IACAF,UAAU,CAACD,OAAO,CAAC,GAAG;MACpBzG,IAAI,EAAEqG,YAAY,GAAGA,YAAY,CAACrG,IAAI,GAAGqG,YAAY,CAACpK,KAAK,GAAG,CAAC;AAC/DA,MAAAA,KAAK,EAAE,CAAC;AACR8D,MAAAA,WAAW,EAAE,CAAC;MACd7D,MAAM,EAAE,IAAI,CAAC4E,QAAQ;AACrBgG,MAAAA,MAAM,EAAE,CAAA;KACO,CAAA;AACjB,IAAA,IAAI5J,IAAI,IAAIA,IAAI,CAACI,YAAY,EAAE;MAC7B,IAAIyJ,cAAc,GAAG,CAAC,CAAA;AACtB,MAAA,MAAMC,eAAe,GACnB9J,IAAI,CAACI,YAAY,CAACJ,IAAI,CAACI,YAAY,CAACgC,MAAM,GAAG,CAAC,CAAC,CAACA,MAAM,CAAA;MACxD,QAAQ,IAAI,CAACb,SAAS;AACpB,QAAA,KAAKwI,IAAI;AACPF,UAAAA,cAAc,GAAGT,OAAO,GAAGU,eAAe,GAAG/K,KAAK,GAAG,CAAC,CAAA;AACtD,UAAA,MAAA;AACF,QAAA,KAAK+F,MAAM;AACT+E,UAAAA,cAAc,GAAG,CAACC,eAAe,GAAG/K,KAAK,IAAI,CAAC,CAAA;AAC9C,UAAA,MAAA;AACF,QAAA,KAAKuK,KAAK;AACRO,UAAAA,cAAc,GAAGT,OAAO,GAAG,CAAC,GAAGU,eAAe,GAAG/K,KAAK,CAAA;AACtD,UAAA,MAAA;AACF;AACF,OAAA;MACA8K,cAAc,IAAI,IAAI,CAACG,eAAe,IAAIZ,OAAO,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA;AAC3D,MAAA,KACE,IAAIlH,CAAC,GAAGkH,OAAO,GAAGG,OAAO,GAAG,CAAC,GAAG,CAAC,EACjCH,OAAO,GAAGlH,CAAC,IAAI,CAAC,GAAGA,CAAC,GAAGqH,OAAO,EAC9BH,OAAO,GAAGlH,CAAC,EAAE,GAAGA,CAAC,EAAE,EACnB;AACAiH,QAAAA,YAAY,GAAGK,UAAU,CAACtH,CAAC,CAAC,CAAA;QAC5B,IAAI2H,cAAc,GAAGC,eAAe,EAAE;AACpCD,UAAAA,cAAc,IAAIC,eAAe,CAAA;AACnC,SAAC,MAAM,IAAID,cAAc,GAAG,CAAC,EAAE;AAC7BA,UAAAA,cAAc,IAAIC,eAAe,CAAA;AACnC,SAAA;AACA;AACA;AACA,QAAA,IAAI,CAACG,kBAAkB,CAACJ,cAAc,EAAEV,YAAY,CAAC,CAAA;QACrDU,cAAc,IAAIV,YAAY,CAACtG,WAAW,CAAA;AAC5C,OAAA;AACF,KAAA;IACA,OAAO;AAAE9D,MAAAA,KAAK,EAAEA,KAAK;AAAEmL,MAAAA,WAAW,EAAE,CAAA;KAAG,CAAA;AACzC,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACED,EAAAA,kBAAkBA,CAACJ,cAAsB,EAAEV,YAA0B,EAAE;IACrE,MAAMgB,cAAc,GAAGN,cAAc,GAAGV,YAAY,CAACtG,WAAW,GAAG,CAAC;MAClE7C,IAAI,GAAG,IAAI,CAACA,IAAK,CAAA;;AAEnB;AACA,IAAA,MAAMoK,IAAI,GAAGC,cAAc,CAACrK,IAAI,CAACA,IAAI,EAAEmK,cAAc,EAAEnK,IAAI,CAACI,YAAY,CAAE,CAAA;IAC1E+I,YAAY,CAACnC,UAAU,GAAGoD,IAAI,CAACE,CAAC,GAAGtK,IAAI,CAACuK,UAAU,CAACD,CAAC,CAAA;IACpDnB,YAAY,CAAClC,SAAS,GAAGmD,IAAI,CAACI,CAAC,GAAGxK,IAAI,CAACuK,UAAU,CAACC,CAAC,CAAA;AACnDrB,IAAAA,YAAY,CAAChC,KAAK,GAAGiD,IAAI,CAACjD,KAAK,IAAI,IAAI,CAACkC,QAAQ,KAAKC,KAAK,GAAGmB,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC,CAAA;AAC3E,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEf,eAAeA,CACbD,QAAgB,EAChB3G,SAAiB,EACjBM,SAAiB,EACjB6F,YAAqB,EACrByB,QAAkB,EACJ;IACd,MAAMC,KAAK,GAAG,IAAI,CAACC,2BAA2B,CAAC9H,SAAS,EAAEM,SAAS,CAAC;AAClEyH,MAAAA,SAAS,GAAG5B,YAAY,GACpB,IAAI,CAAC2B,2BAA2B,CAAC9H,SAAS,EAAEM,SAAS,GAAG,CAAC,CAAC,GAC1D,EAAE;AACN+G,MAAAA,IAAI,GAAG,IAAI,CAAC3C,YAAY,CAACiC,QAAQ,EAAEkB,KAAK,EAAE1B,YAAY,EAAE4B,SAAS,CAAC,CAAA;AACpE,IAAA,IAAIjI,WAAW,GAAGuH,IAAI,CAACvH,WAAW;MAChC9D,KAAK,GAAGqL,IAAI,CAACrL,KAAK;MAClBiK,WAAW,CAAA;AAEb,IAAA,IAAI,IAAI,CAACA,WAAW,KAAK,CAAC,EAAE;AAC1BA,MAAAA,WAAW,GAAG,IAAI,CAACC,sBAAsB,EAAE,CAAA;AAC3ClK,MAAAA,KAAK,IAAIiK,WAAW,CAAA;AACpBnG,MAAAA,WAAW,IAAImG,WAAW,CAAA;AAC5B,KAAA;AAEA,IAAA,MAAM+B,GAAiB,GAAG;MACxBhM,KAAK;AACL+D,MAAAA,IAAI,EAAE,CAAC;MACP9D,MAAM,EAAE4L,KAAK,CAAChH,QAAQ;MACtBf,WAAW;MACX+G,MAAM,EAAEgB,KAAK,CAAChB,MAAAA;KACf,CAAA;AACD,IAAA,IAAIvG,SAAS,GAAG,CAAC,IAAI,CAACsH,QAAQ,EAAE;AAC9B,MAAA,MAAMK,WAAW,GAAG,IAAI,CAACtI,YAAY,CAACK,SAAS,CAAC,CAACM,SAAS,GAAG,CAAC,CAAC,CAAA;AAC/D0H,MAAAA,GAAG,CAACjI,IAAI,GACNkI,WAAW,CAAClI,IAAI,GAAGkI,WAAW,CAACjM,KAAK,GAAGqL,IAAI,CAACvH,WAAW,GAAGuH,IAAI,CAACrL,KAAK,CAAA;AACxE,KAAA;AACA,IAAA,OAAOgM,GAAG,CAAA;AACZ,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACUnE,mBAAmBA,CAAC7D,SAAiB,EAAU;AACrD,IAAA,MAAMkI,EAAE,GAAG,IAAI,CAACC,aAAa,CAAA;AAC7B,IAAA,IAAID,EAAE,CAAClI,SAAS,CAAC,EAAE;MACjB,OAAOkI,EAAE,CAAClI,SAAS,CAAC,CAAA;AACtB,KAAA;;AAEA;AACA;IACA,IAAIoI,SAAS,GAAG,IAAI,CAACvC,eAAe,CAAC7F,SAAS,EAAE,CAAC,CAAC,CAAA;IAClD,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACxB,UAAU,CAACoC,SAAS,CAAC,CAACX,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;AACrEiJ,MAAAA,SAAS,GAAGV,IAAI,CAACW,GAAG,CAAC,IAAI,CAACxC,eAAe,CAAC7F,SAAS,EAAEb,CAAC,CAAC,EAAEiJ,SAAS,CAAC,CAAA;AACrE,KAAA;IAEA,OAAQF,EAAE,CAAClI,SAAS,CAAC,GAAGoI,SAAS,GAAG,IAAI,CAACE,aAAa,CAAA;AACxD,GAAA;;AAEA;AACF;AACA;AACA;AACA;EACEpF,eAAeA,CAAClD,SAAiB,EAAU;IACzC,OAAO,IAAI,CAAC6D,mBAAmB,CAAC7D,SAAS,CAAC,GAAG,IAAI,CAACuI,UAAU,CAAA;AAC9D,GAAA;;AAEA;AACF;AACA;AACEhK,EAAAA,cAAcA,GAAG;IACf,IAAItC,MAAM,GAAG,CAAC,CAAA;AACd,IAAA,KAAK,IAAIkD,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACxB,UAAU,CAACyB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;AAC1DlD,MAAAA,MAAM,IACJkD,CAAC,KAAKC,GAAG,GAAG,CAAC,GAAG,IAAI,CAACyE,mBAAmB,CAAC1E,CAAC,CAAC,GAAG,IAAI,CAAC+D,eAAe,CAAC/D,CAAC,CAAC,CAAA;AACzE,KAAA;AACA,IAAA,OAAOlD,MAAM,CAAA;AACf,GAAA;;AAEA;AACF;AACA;AACA;AACE6G,EAAAA,cAAcA,GAAW;AACvB,IAAA,OAAO,IAAI,CAAC0B,SAAS,KAAK,KAAK,GAAG,CAAC,IAAI,CAACxI,KAAK,GAAG,CAAC,GAAG,IAAI,CAACA,KAAK,GAAG,CAAC,CAAA;AACpE,GAAA;;AAEA;AACF;AACA;AACA;AACEgH,EAAAA,aAAaA,GAAW;AACtB,IAAA,OAAO,CAAC,IAAI,CAAC/G,MAAM,GAAG,CAAC,CAAA;AACzB,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACEuM,EAAAA,iBAAiBA,CACfvH,GAA6B,EAC7BqB,MAAiC,EACjC;IACArB,GAAG,CAAC8C,IAAI,EAAE,CAAA;IACV,IAAI0E,WAAW,GAAG,CAAC,CAAA;AACnB,IAAA,MAAM1I,IAAI,GAAG,IAAI,CAAC+C,cAAc,EAAE;AAChCP,MAAAA,GAAG,GAAG,IAAI,CAACS,aAAa,EAAE,CAAA;AAC5B,IAAA,KAAK,IAAI7D,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACxB,UAAU,CAACyB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;AAC1D,MAAA,IAAI,CAACkD,eAAe,CAClBC,MAAM,EACNrB,GAAG,EACH,IAAI,CAACrD,UAAU,CAACuB,CAAC,CAAC,EAClBY,IAAI,GAAG,IAAI,CAACsD,kBAAkB,CAAClE,CAAC,CAAC,EACjCoD,GAAG,GAAGkG,WAAW,GAAG,IAAI,CAAC5E,mBAAmB,CAAC1E,CAAC,CAAC,EAC/CA,CACF,CAAC,CAAA;AACDsJ,MAAAA,WAAW,IAAI,IAAI,CAACvF,eAAe,CAAC/D,CAAC,CAAC,CAAA;AACxC,KAAA;IACA8B,GAAG,CAACsD,OAAO,EAAE,CAAA;AACf,GAAA;;AAEA;AACF;AACA;AACA;EACE7C,eAAeA,CAACT,GAA6B,EAAE;AAC7C,IAAA,IAAI,CAAC,IAAI,CAACyH,IAAI,IAAI,CAAC,IAAI,CAAChG,QAAQ,CAACiG,IAAI,CAAC,EAAE;AACtC,MAAA,OAAA;AACF,KAAA;AAEA,IAAA,IAAI,CAACH,iBAAiB,CAACvH,GAAG,EAAE,UAAU,CAAC,CAAA;AACzC,GAAA;;AAEA;AACF;AACA;AACA;EACEQ,iBAAiBA,CAACR,GAA6B,EAAE;AAC/C,IAAA,IAAI,CAAC,CAAC,IAAI,CAAC2H,MAAM,IAAI,IAAI,CAACC,WAAW,KAAK,CAAC,KAAK,IAAI,CAACC,aAAa,EAAE,EAAE;AACpE,MAAA,OAAA;AACF,KAAA;IAEA,IAAI,IAAI,CAACC,MAAM,IAAI,CAAC,IAAI,CAACA,MAAM,CAACC,YAAY,EAAE;AAC5C,MAAA,IAAI,CAACvE,aAAa,CAACxD,GAAG,CAAC,CAAA;AACzB,KAAA;IAEAA,GAAG,CAAC8C,IAAI,EAAE,CAAA;IACV,IAAI,CAACkF,YAAY,CAAChI,GAAG,EAAE,IAAI,CAACiI,eAAe,CAAC,CAAA;IAC5CjI,GAAG,CAACkI,SAAS,EAAE,CAAA;AACf,IAAA,IAAI,CAACX,iBAAiB,CAACvH,GAAG,EAAE,YAAY,CAAC,CAAA;IACzCA,GAAG,CAACmI,SAAS,EAAE,CAAA;IACfnI,GAAG,CAACsD,OAAO,EAAE,CAAA;AACf,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE/B,EAAAA,YAAYA,CACVF,MAAiC,EACjCrB,GAA6B,EAC7BjC,IAAgB,EAChBe,IAAY,EACZwC,GAAW,EACXvC,SAAiB,EACjB;IACA,MAAMqJ,SAAS,GAAG,IAAI,CAAC7K,SAAS,CAACC,QAAQ,CAACC,OAAO,CAAC;MAChDzB,IAAI,GAAG,IAAI,CAACA,IAAI;AAChBqM,MAAAA,QAAQ,GACN,CAACD,SAAS,IACV,IAAI,CAACpD,WAAW,KAAK,CAAC,IACtB,IAAI,CAAC6C,aAAa,CAAC9I,SAAS,CAAC,IAC7B,CAAC/C,IAAI;AACPsM,MAAAA,KAAK,GAAG,IAAI,CAAC/E,SAAS,KAAK,KAAK;MAChCgF,IAAI,GAAG,IAAI,CAAChF,SAAS,KAAK,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;AACxC;AACA;MACAiF,gBAAgB,GAAGxI,GAAG,CAACuD,SAAS,CAAA;AAElC,IAAA,IAAIkF,WAAW;MACbC,SAAS;AACTC,MAAAA,aAAa,GAAG,EAAE;MAClB9F,OAAO;AACPR,MAAAA,QAAQ,GAAG,CAAC;MACZuG,YAAY;MACZC,WAAW,CAAA;IAEb7I,GAAG,CAAC8C,IAAI,EAAE,CAAA;AACV,IAAA,IAAI0F,gBAAgB,KAAK,IAAI,CAACjF,SAAS,EAAE;AACvCvD,MAAAA,GAAG,CAACnF,MAAM,CAACiO,YAAY,CAAC,KAAK,EAAER,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,CAAA;AACrDtI,MAAAA,GAAG,CAACuD,SAAS,GAAG+E,KAAK,GAAG,KAAK,GAAG,KAAK,CAAA;AACrCtI,MAAAA,GAAG,CAACzC,SAAS,GAAG+K,KAAK,GAAGvC,IAAI,GAAGT,KAAK,CAAA;AACtC,KAAA;IACAhE,GAAG,IAAI,IAAI,CAACsB,mBAAmB,CAAC7D,SAAS,CAAC,GAAG,IAAI,CAACsE,iBAAiB,CAAA;AACnE,IAAA,IAAIgF,QAAQ,EAAE;AACZ;AACA;MACA,IAAI,CAACU,WAAW,CAAC1H,MAAM,EAAErB,GAAG,EAAEjB,SAAS,EAAE,CAAC,EAAEhB,IAAI,CAACiL,IAAI,CAAC,EAAE,CAAC,EAAElK,IAAI,EAAEwC,GAAG,CAAC,CAAA;MACrEtB,GAAG,CAACsD,OAAO,EAAE,CAAA;AACb,MAAA,OAAA;AACF,KAAA;AACA,IAAA,KAAK,IAAIpF,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGJ,IAAI,CAACK,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAIC,GAAG,EAAED,CAAC,EAAE,EAAE;MACpD0K,YAAY,GAAG1K,CAAC,KAAKC,GAAG,IAAI,IAAI,CAAC6G,WAAW,IAAIhJ,IAAI,CAAA;AACpD2M,MAAAA,aAAa,IAAI5K,IAAI,CAACG,CAAC,CAAC,CAAA;MACxB2E,OAAO,GAAG,IAAI,CAACnE,YAAY,CAACK,SAAS,CAAC,CAACb,CAAC,CAA2B,CAAA;MACnE,IAAImE,QAAQ,KAAK,CAAC,EAAE;QAClBvD,IAAI,IAAIyJ,IAAI,IAAI1F,OAAO,CAAChE,WAAW,GAAGgE,OAAO,CAAC9H,KAAK,CAAC,CAAA;QACpDsH,QAAQ,IAAIQ,OAAO,CAAC9H,KAAK,CAAA;AAC3B,OAAC,MAAM;QACLsH,QAAQ,IAAIQ,OAAO,CAAChE,WAAW,CAAA;AACjC,OAAA;AACA,MAAA,IAAIuJ,SAAS,IAAI,CAACQ,YAAY,EAAE;QAC9B,IAAI,IAAI,CAACjK,cAAc,CAACC,IAAI,CAACb,IAAI,CAACG,CAAC,CAAC,CAAC,EAAE;AACrC0K,UAAAA,YAAY,GAAG,IAAI,CAAA;AACrB,SAAA;AACF,OAAA;MACA,IAAI,CAACA,YAAY,EAAE;AACjB;QACAH,WAAW,GACTA,WAAW,IAAI,IAAI,CAAC5B,2BAA2B,CAAC9H,SAAS,EAAEb,CAAC,CAAC,CAAA;QAC/DwK,SAAS,GAAG,IAAI,CAAC7B,2BAA2B,CAAC9H,SAAS,EAAEb,CAAC,GAAG,CAAC,CAAC,CAAA;QAC9D0K,YAAY,GAAGK,eAAe,CAACR,WAAW,EAAEC,SAAS,EAAE,KAAK,CAAC,CAAA;AAC/D,OAAA;AACA,MAAA,IAAIE,YAAY,EAAE;AAChB,QAAA,IAAI5M,IAAI,EAAE;UACRgE,GAAG,CAAC8C,IAAI,EAAE,CAAA;UACV9C,GAAG,CAAC+C,SAAS,CAACF,OAAO,CAACG,UAAU,EAAEH,OAAO,CAACI,SAAS,CAAC,CAAA;AACpDjD,UAAAA,GAAG,CAACkD,MAAM,CAACL,OAAO,CAACM,KAAK,CAAC,CAAA;AACzB,UAAA,IAAI,CAAC4F,WAAW,CACd1H,MAAM,EACNrB,GAAG,EACHjB,SAAS,EACTb,CAAC,EACDyK,aAAa,EACb,CAACtG,QAAQ,GAAG,CAAC,EACb,CACF,CAAC,CAAA;UACDrC,GAAG,CAACsD,OAAO,EAAE,CAAA;AACf,SAAC,MAAM;AACLuF,UAAAA,WAAW,GAAG/J,IAAI,CAAA;AAClB,UAAA,IAAI,CAACiK,WAAW,CACd1H,MAAM,EACNrB,GAAG,EACHjB,SAAS,EACTb,CAAC,EACDyK,aAAa,EACbE,WAAW,EACXvH,GACF,CAAC,CAAA;AACH,SAAA;AACAqH,QAAAA,aAAa,GAAG,EAAE,CAAA;AAClBF,QAAAA,WAAW,GAAGC,SAAS,CAAA;QACvB5J,IAAI,IAAIyJ,IAAI,GAAGlG,QAAQ,CAAA;AACvBA,QAAAA,QAAQ,GAAG,CAAC,CAAA;AACd,OAAA;AACF,KAAA;IACArC,GAAG,CAACsD,OAAO,EAAE,CAAA;AACf,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE4F,kCAAkCA,CAACC,MAAe,EAAE;AAClD;IACA,MAAMpO,KAAK,GAAG,IAAI,CAACA,KAAK,GAAG,IAAI,CAAC6M,WAAW;AACzC5M,MAAAA,MAAM,GAAG,IAAI,CAACA,MAAM,GAAG,IAAI,CAAC4M,WAAW;MACvCwB,OAAO,GAAGtO,sBAAsB,CAAC;QAC/BC,KAAK;AACLC,QAAAA,MAAAA;AACF,OAAC,CAAC;AACFqO,MAAAA,IAAI,GAAGD,OAAO,CAACnO,UAAU,CAAC,IAAI,CAAE,CAAA;IAClCmO,OAAO,CAACrO,KAAK,GAAGA,KAAK,CAAA;IACrBqO,OAAO,CAACpO,MAAM,GAAGA,MAAM,CAAA;IACvBqO,IAAI,CAACnB,SAAS,EAAE,CAAA;AAChBmB,IAAAA,IAAI,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;AACjBD,IAAAA,IAAI,CAACE,MAAM,CAACxO,KAAK,EAAE,CAAC,CAAC,CAAA;AACrBsO,IAAAA,IAAI,CAACE,MAAM,CAACxO,KAAK,EAAEC,MAAM,CAAC,CAAA;AAC1BqO,IAAAA,IAAI,CAACE,MAAM,CAAC,CAAC,EAAEvO,MAAM,CAAC,CAAA;IACtBqO,IAAI,CAAClB,SAAS,EAAE,CAAA;IAChBkB,IAAI,CAACtG,SAAS,CAAChI,KAAK,GAAG,CAAC,EAAEC,MAAM,GAAG,CAAC,CAAC,CAAA;IACrCqO,IAAI,CAAC1H,SAAS,GAAGwH,MAAM,CAACK,MAAM,CAACH,IAAI,CAAE,CAAA;AACrC,IAAA,IAAI,CAACI,8BAA8B,CAACJ,IAAI,EAAEF,MAAM,CAAC,CAAA;IACjDE,IAAI,CAAC5B,IAAI,EAAE,CAAA;AACX,IAAA,OAAO4B,IAAI,CAACK,aAAa,CAACN,OAAO,EAAE,WAAW,CAAC,CAAA;AACjD,GAAA;AAEAO,EAAAA,YAAYA,CACV3J,GAA6B,EAC7B4J,QAAqB,EACrBT,MAAwB,EACc;IACtC,IAAIU,OAAe,EAAEC,OAAe,CAAA;AACpC,IAAA,IAAIC,QAAQ,CAACZ,MAAM,CAAC,EAAE;AACpB,MAAA,IACGA,MAAM,CAAwBa,aAAa,KAAK,YAAY,IAC5Db,MAAM,CAAwBc,iBAAiB,IAC/Cd,MAAM,CAAae,gBAAgB,EACpC;AACA;AACA;AACA;AACA;AACAL,QAAAA,OAAO,GAAG,CAAC,IAAI,CAAC9O,KAAK,GAAG,CAAC,CAAA;AACzB+O,QAAAA,OAAO,GAAG,CAAC,IAAI,CAAC9O,MAAM,GAAG,CAAC,CAAA;AAC1BgF,QAAAA,GAAG,CAAC+C,SAAS,CAAC8G,OAAO,EAAEC,OAAO,CAAC,CAAA;QAC/B9J,GAAG,CAAC4J,QAAQ,CAAC,GAAG,IAAI,CAACV,kCAAkC,CAACC,MAAM,CAAC,CAAA;QAC/D,OAAO;UAAEU,OAAO;AAAEC,UAAAA,OAAAA;SAAS,CAAA;AAC7B,OAAC,MAAM;AACL;QACA9J,GAAG,CAAC4J,QAAQ,CAAC,GAAGT,MAAM,CAACK,MAAM,CAACxJ,GAAG,CAAE,CAAA;AACnC,QAAA,OAAO,IAAI,CAACyJ,8BAA8B,CAACzJ,GAAG,EAAEmJ,MAAM,CAAC,CAAA;AACzD,OAAA;AACF,KAAC,MAAM;AACL;AACAnJ,MAAAA,GAAG,CAAC4J,QAAQ,CAAC,GAAGT,MAAM,CAAA;AACxB,KAAA;IACA,OAAO;AAAEU,MAAAA,OAAO,EAAE,CAAC;AAAEC,MAAAA,OAAO,EAAE,CAAA;KAAG,CAAA;AACnC,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACEK,EAAAA,gBAAgBA,CACdnK,GAA6B,EAAAoK,IAAA,EAK7B;IAAA,IAJA;MACEzC,MAAM;AACNC,MAAAA,WAAAA;AAC4D,KAAC,GAAAwC,IAAA,CAAA;IAE/DpK,GAAG,CAACqK,SAAS,GAAGzC,WAAW,CAAA;AAC3B5H,IAAAA,GAAG,CAACsK,OAAO,GAAG,IAAI,CAACC,aAAa,CAAA;AAChCvK,IAAAA,GAAG,CAACwK,cAAc,GAAG,IAAI,CAACC,gBAAgB,CAAA;AAC1CzK,IAAAA,GAAG,CAAC0K,QAAQ,GAAG,IAAI,CAACC,cAAc,CAAA;AAClC3K,IAAAA,GAAG,CAAC4K,UAAU,GAAG,IAAI,CAACC,gBAAgB,CAAA;IACtC,OAAO,IAAI,CAAClB,YAAY,CAAC3J,GAAG,EAAE,aAAa,EAAE2H,MAAO,CAAC,CAAA;AACvD,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACEmD,EAAAA,cAAcA,CAAC9K,GAA6B,EAAA+K,KAAA,EAAgC;IAAA,IAA9B;AAAEtD,MAAAA,IAAAA;AAAyB,KAAC,GAAAsD,KAAA,CAAA;IACxE,OAAO,IAAI,CAACpB,YAAY,CAAC3J,GAAG,EAAE,WAAW,EAAEyH,IAAK,CAAC,CAAA;AACnD,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEsB,EAAAA,WAAWA,CACT1H,MAAiC,EACjCrB,GAA6B,EAC7BjB,SAAiB,EACjBM,SAAiB,EACjBqE,KAAa,EACb5E,IAAY,EACZwC,GAAW,EACX;IACA,MAAM0J,IAAI,GAAG,IAAI,CAACC,oBAAoB,CAAClM,SAAS,EAAEM,SAAS,CAAC;MAC1D6L,QAAQ,GAAG,IAAI,CAACrE,2BAA2B,CAAC9H,SAAS,EAAEM,SAAS,CAAC;AACjE8L,MAAAA,UAAU,GAAG9J,MAAM,KAAK,UAAU,IAAI6J,QAAQ,CAACzD,IAAI;MACnD2D,YAAY,GACV/J,MAAM,KAAK,YAAY,IAAI6J,QAAQ,CAACvD,MAAM,IAAIuD,QAAQ,CAACtD,WAAW,CAAA;AAEtE,IAAA,IAAI,CAACwD,YAAY,IAAI,CAACD,UAAU,EAAE;AAChC,MAAA,OAAA;AACF,KAAA;IACAnL,GAAG,CAAC8C,IAAI,EAAE,CAAA;IAEV9C,GAAG,CAACiB,IAAI,GAAG,IAAI,CAACC,mBAAmB,CAACgK,QAAQ,CAAC,CAAA;IAE7C,IAAIF,IAAI,CAACxJ,mBAAmB,EAAE;AAC5B,MAAA,IAAI,CAACgC,aAAa,CAACxD,GAAG,CAAC,CAAA;AACzB,KAAA;IACA,IAAIgL,IAAI,CAACpF,MAAM,EAAE;MACftE,GAAG,IAAI0J,IAAI,CAACpF,MAAM,CAAA;AACpB,KAAA;AAEA,IAAA,IAAIuF,UAAU,EAAE;MACd,MAAME,WAAW,GAAG,IAAI,CAACP,cAAc,CAAC9K,GAAG,EAAEkL,QAAQ,CAAC,CAAA;AACtDlL,MAAAA,GAAG,CAACsL,QAAQ,CACV5H,KAAK,EACL5E,IAAI,GAAGuM,WAAW,CAACxB,OAAO,EAC1BvI,GAAG,GAAG+J,WAAW,CAACvB,OACpB,CAAC,CAAA;AACH,KAAA;AAEA,IAAA,IAAIsB,YAAY,EAAE;MAChB,MAAMG,aAAa,GAAG,IAAI,CAACpB,gBAAgB,CAACnK,GAAG,EAAEkL,QAAQ,CAAC,CAAA;AAC1DlL,MAAAA,GAAG,CAACwL,UAAU,CACZ9H,KAAK,EACL5E,IAAI,GAAGyM,aAAa,CAAC1B,OAAO,EAC5BvI,GAAG,GAAGiK,aAAa,CAACzB,OACtB,CAAC,CAAA;AACH,KAAA;IAEA9J,GAAG,CAACsD,OAAO,EAAE,CAAA;AACf,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACEmI,EAAAA,cAAcA,CAACC,KAAa,EAAEC,GAAW,EAAE;IACzC,IAAI,CAACC,UAAU,CAACF,KAAK,EAAEC,GAAG,EAAE,IAAI,CAACE,WAAW,CAAC,CAAA;AAC/C,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACEC,EAAAA,YAAYA,CAACJ,KAAa,EAAEC,GAAW,EAAE;IACvC,IAAI,CAACC,UAAU,CAACF,KAAK,EAAEC,GAAG,EAAE,IAAI,CAACI,SAAS,CAAC,CAAA;AAC7C,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACYH,EAAAA,UAAUA,CAClBF,KAAa,EACbC,GAAW,EACXK,MAGC,EACD;IACA,MAAMC,GAAG,GAAG,IAAI,CAAC/M,mBAAmB,CAACwM,KAAK,EAAE,IAAI,CAAC;AAC/C9L,MAAAA,QAAQ,GAAG,IAAI,CAAC8C,oBAAoB,CAClCuJ,GAAG,CAAClN,SAAS,EACbkN,GAAG,CAAC5M,SAAS,EACb,UACF,CAAC;AACD6M,MAAAA,EAAE,GAAG,IAAI,CAACxJ,oBAAoB,CAACuJ,GAAG,CAAClN,SAAS,EAAEkN,GAAG,CAAC5M,SAAS,EAAE,QAAQ,CAAC;AACtEuH,MAAAA,KAAK,GAAG;AACNhH,QAAAA,QAAQ,EAAEA,QAAQ,GAAGoM,MAAM,CAACG,IAAI;AAChCvG,QAAAA,MAAM,EAAEsG,EAAE,GAAGtM,QAAQ,GAAGoM,MAAM,CAACI,QAAAA;OAChC,CAAA;IACH,IAAI,CAACC,kBAAkB,CAACzF,KAAK,EAAE8E,KAAK,EAAEC,GAAG,CAAC,CAAA;AAC5C,GAAA;;AAEA;AACF;AACA;AACA;AACA;EACEvJ,kBAAkBA,CAACrD,SAAiB,EAAU;AAC5C,IAAA,MAAMsL,SAAS,GAAG,IAAI,CAAC/L,YAAY,CAACS,SAAS,CAAC;AAC5CuN,MAAAA,QAAQ,GAAG,IAAI,CAACvR,KAAK,GAAGsP,SAAS;MACjC9M,SAAS,GAAG,IAAI,CAACA,SAAS;MAC1BgG,SAAS,GAAG,IAAI,CAACA,SAAS;AAC1BlF,MAAAA,eAAe,GAAG,IAAI,CAACA,eAAe,CAACU,SAAS,CAAC,CAAA;IACnD,IAAI6C,UAAU,GAAG,CAAC,CAAA;IAClB,IACErE,SAAS,KAAKE,OAAO,IACpBF,SAAS,KAAKgP,cAAc,IAAI,CAAClO,eAAgB,IACjDd,SAAS,KAAKiP,aAAa,IAAI,CAACnO,eAAgB,IAChDd,SAAS,KAAKkP,YAAY,IAAI,CAACpO,eAAgB,EAChD;AACA,MAAA,OAAO,CAAC,CAAA;AACV,KAAA;IACA,IAAId,SAAS,KAAKuD,MAAM,EAAE;MACxBc,UAAU,GAAG0K,QAAQ,GAAG,CAAC,CAAA;AAC3B,KAAA;IACA,IAAI/O,SAAS,KAAK+H,KAAK,EAAE;AACvB1D,MAAAA,UAAU,GAAG0K,QAAQ,CAAA;AACvB,KAAA;IACA,IAAI/O,SAAS,KAAKgP,cAAc,EAAE;MAChC3K,UAAU,GAAG0K,QAAQ,GAAG,CAAC,CAAA;AAC3B,KAAA;IACA,IAAI/O,SAAS,KAAKiP,aAAa,EAAE;AAC/B5K,MAAAA,UAAU,GAAG0K,QAAQ,CAAA;AACvB,KAAA;IACA,IAAI/I,SAAS,KAAK,KAAK,EAAE;MACvB,IACEhG,SAAS,KAAK+H,KAAK,IACnB/H,SAAS,KAAKE,OAAO,IACrBF,SAAS,KAAKiP,aAAa,EAC3B;AACA5K,QAAAA,UAAU,GAAG,CAAC,CAAA;OACf,MAAM,IAAIrE,SAAS,KAAKwI,IAAI,IAAIxI,SAAS,KAAKkP,YAAY,EAAE;QAC3D7K,UAAU,GAAG,CAAC0K,QAAQ,CAAA;OACvB,MAAM,IAAI/O,SAAS,KAAKuD,MAAM,IAAIvD,SAAS,KAAKgP,cAAc,EAAE;AAC/D3K,QAAAA,UAAU,GAAG,CAAC0K,QAAQ,GAAG,CAAC,CAAA;AAC5B,OAAA;AACF,KAAA;AACA,IAAA,OAAO1K,UAAU,CAAA;AACnB,GAAA;;AAEA;AACF;AACA;AACE3E,EAAAA,WAAWA,GAAG;IACZ,IAAI,CAACyP,gBAAgB,GAAG,KAAK,CAAA;IAC7B,IAAI,CAACC,YAAY,GAAG,EAAE,CAAA;IACtB,IAAI,CAACzF,aAAa,GAAG,EAAE,CAAA;IACvB,IAAI,CAACxI,YAAY,GAAG,EAAE,CAAA;AACxB,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEJ,YAAYA,CAACS,SAAiB,EAAU;IACtC,IAAI,IAAI,CAAC4N,YAAY,CAAC5N,SAAS,CAAC,KAAK0F,SAAS,EAAE;AAC9C,MAAA,OAAO,IAAI,CAACkI,YAAY,CAAC5N,SAAS,CAAC,CAAA;AACrC,KAAA;IAEA,MAAM;AAAEhE,MAAAA,KAAAA;AAAM,KAAC,GAAG,IAAI,CAAC8J,WAAW,CAAC9F,SAAS,CAAC,CAAA;AAC7C,IAAA,IAAI,CAAC4N,YAAY,CAAC5N,SAAS,CAAC,GAAGhE,KAAK,CAAA;AACpC,IAAA,OAAOA,KAAK,CAAA;AACd,GAAA;AAEAkK,EAAAA,sBAAsBA,GAAG;AACvB,IAAA,IAAI,IAAI,CAACD,WAAW,KAAK,CAAC,EAAE;MAC1B,OAAQ,IAAI,CAACpF,QAAQ,GAAG,IAAI,CAACoF,WAAW,GAAI,IAAI,CAAA;AAClD,KAAA;AACA,IAAA,OAAO,CAAC,CAAA;AACV,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACEtC,EAAAA,oBAAoBA,CAClB3D,SAAiB,EACjBM,SAAiB,EACjBuK,QAAW,EACF;AAAA,IAAA,IAAAgD,mBAAA,CAAA;IACT,MAAMlM,SAAS,GAAG,IAAI,CAACuK,oBAAoB,CAAClM,SAAS,EAAEM,SAAS,CAAC,CAAA;AACjE,IAAA,OAAA,CAAAuN,mBAAA,GAAQlM,SAAS,CAACkJ,QAAQ,CAAC,MAAA,IAAA,IAAAgD,mBAAA,KAAA,KAAA,CAAA,GAAAA,mBAAA,GAAI,IAAI,CAAChD,QAAQ,CAAC,CAAA;AAC/C,GAAA;;AAEA;AACF;AACA;AACA;AACExJ,EAAAA,qBAAqBA,CACnBJ,GAA6B,EAC7B6M,IAA8C,EAC9C;AACA,IAAA,IAAI,CAAC,IAAI,CAACA,IAAI,CAAC,IAAI,CAAC,IAAI,CAACpL,QAAQ,CAACoL,IAAI,CAAC,EAAE;AACvC,MAAA,OAAA;AACF,KAAA;AACA,IAAA,IAAIC,SAAS,GAAG,IAAI,CAAC/K,aAAa,EAAE,CAAA;AACpC,IAAA,MAAMH,UAAU,GAAG,IAAI,CAACC,cAAc,EAAE;MACtC7F,IAAI,GAAG,IAAI,CAACA,IAAI;AAChBgJ,MAAAA,WAAW,GAAG,IAAI,CAACC,sBAAsB,EAAE;AAC3C8H,MAAAA,aAAa,GACXF,IAAI,KAAK,aAAa,GAAG,GAAG,GAAGA,IAAI,KAAK,UAAU,GAAG,CAAC,GAAG,CAAC;AAC5D/C,MAAAA,OAAO,GAAG,IAAI,CAACkD,OAAO,CAACH,IAAI,CAAC,CAAA;AAC9B,IAAA,KAAK,IAAI3O,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACxB,UAAU,CAACyB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;AAC1D,MAAA,MAAM8D,YAAY,GAAG,IAAI,CAACC,eAAe,CAAC/D,CAAC,CAAC,CAAA;AAC5C,MAAA,IAAI,CAAC,IAAI,CAAC2O,IAAI,CAAC,IAAI,CAAC,IAAI,CAACpL,QAAQ,CAACoL,IAAI,EAAE3O,CAAC,CAAC,EAAE;AAC1C4O,QAAAA,SAAS,IAAI9K,YAAY,CAAA;AACzB,QAAA,SAAA;AACF,OAAA;AACA,MAAA,MAAMjE,IAAI,GAAG,IAAI,CAACpB,UAAU,CAACuB,CAAC,CAAC,CAAA;AAC/B,MAAA,MAAMiJ,SAAS,GAAGnF,YAAY,GAAG,IAAI,CAACsF,UAAU,CAAA;AAChD,MAAA,MAAMnF,cAAc,GAAG,IAAI,CAACC,kBAAkB,CAAClE,CAAC,CAAC,CAAA;MACjD,IAAIoE,QAAQ,GAAG,CAAC,CAAA;MAChB,IAAID,QAAQ,GAAG,CAAC,CAAA;MAChB,IAAI4K,cAAc,GAAG,IAAI,CAACvK,oBAAoB,CAACxE,CAAC,EAAE,CAAC,EAAE2O,IAAI,CAAC,CAAA;MAC1D,IAAIK,QAAQ,GAAG,IAAI,CAACxK,oBAAoB,CAACxE,CAAC,EAAE,CAAC,EAAEwJ,IAAI,CAAC,CAAA;MACpD,IAAIyF,YAAY,GAAG,IAAI,CAACzK,oBAAoB,CAC1CxE,CAAC,EACD,CAAC,EACDkP,yBACF,CAAC,CAAA;MACD,IAAIC,iBAAiB,GAAGJ,cAAc,CAAA;MACtC,IAAIK,WAAW,GAAGJ,QAAQ,CAAA;MAC1B,IAAIK,eAAe,GAAGJ,YAAY,CAAA;MAClC,MAAM7L,GAAG,GAAGwL,SAAS,GAAG3F,SAAS,IAAI,CAAC,GAAG,IAAI,CAAC9D,iBAAiB,CAAC,CAAA;MAChE,IAAI8I,IAAI,GAAG,IAAI,CAACvH,eAAe,CAAC1G,CAAC,EAAE,CAAC,CAAC,CAAA;MACrC,IAAIgO,EAAE,GAAG,IAAI,CAACxJ,oBAAoB,CAACxE,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAA;AAClD,MAAA,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEyD,IAAI,GAAGnE,IAAI,CAACK,MAAM,EAAEK,CAAC,GAAGyD,IAAI,EAAEzD,CAAC,EAAE,EAAE;QACjD,MAAMoE,OAAO,GAAG,IAAI,CAACnE,YAAY,CAACR,CAAC,CAAC,CAACO,CAAC,CAA2B,CAAA;QACjE4O,iBAAiB,GAAG,IAAI,CAAC3K,oBAAoB,CAACxE,CAAC,EAAEO,CAAC,EAAEoO,IAAI,CAAC,CAAA;QACzDS,WAAW,GAAG,IAAI,CAAC5K,oBAAoB,CAACxE,CAAC,EAAEO,CAAC,EAAEiJ,IAAI,CAAC,CAAA;QACnD6F,eAAe,GAAG,IAAI,CAAC7K,oBAAoB,CACzCxE,CAAC,EACDO,CAAC,EACD2O,yBACF,CAAC,CAAA;QACD,MAAMI,WAAW,GAAG,IAAI,CAAC5I,eAAe,CAAC1G,CAAC,EAAEO,CAAC,CAAC,CAAA;QAC9C,MAAMgP,SAAS,GAAG,IAAI,CAAC/K,oBAAoB,CAACxE,CAAC,EAAEO,CAAC,EAAE,QAAQ,CAAC,CAAA;AAC3D,QAAA,IAAIzC,IAAI,IAAIqR,iBAAiB,IAAIC,WAAW,EAAE;UAC5C,MAAMI,aAAa,GAAI,IAAI,CAAC9N,QAAQ,GAAG2N,eAAe,GAAI,IAAI,CAAA;UAC9DvN,GAAG,CAAC8C,IAAI,EAAE,CAAA;AACV;UACA9C,GAAG,CAAC2B,SAAS,GAAGuL,QAAkB,CAAA;UAClClN,GAAG,CAAC+C,SAAS,CAACF,OAAO,CAACG,UAAU,EAAEH,OAAO,CAACI,SAAS,CAAC,CAAA;AACpDjD,UAAAA,GAAG,CAACkD,MAAM,CAACL,OAAO,CAACM,KAAK,CAAC,CAAA;UACzBnD,GAAG,CAACoD,QAAQ,CACV,CAACP,OAAO,CAAChE,WAAW,GAAG,CAAC,EACxBiL,OAAO,GAAG0D,WAAW,GAAGC,SAAS,GAAGV,aAAa,GAAGW,aAAa,EACjE7K,OAAO,CAAChE,WAAW,EACnB6O,aACF,CAAC,CAAA;UACD1N,GAAG,CAACsD,OAAO,EAAE,CAAA;SACd,MAAM,IACL,CAAC+J,iBAAiB,KAAKJ,cAAc,IACnCK,WAAW,KAAKJ,QAAQ,IACxBM,WAAW,KAAKrB,IAAI,IACpBoB,eAAe,KAAKJ,YAAY,IAChCM,SAAS,KAAKvB,EAAE,KAClB7J,QAAQ,GAAG,CAAC,EACZ;UACA,MAAMqL,aAAa,GAAI,IAAI,CAAC9N,QAAQ,GAAGuN,YAAY,GAAI,IAAI,CAAA;AAC3D,UAAA,IAAI5K,SAAS,GAAGX,UAAU,GAAGO,cAAc,GAAGG,QAAQ,CAAA;AACtD,UAAA,IAAI,IAAI,CAACiB,SAAS,KAAK,KAAK,EAAE;AAC5BhB,YAAAA,SAAS,GAAG,IAAI,CAACxH,KAAK,GAAGwH,SAAS,GAAGF,QAAQ,CAAA;AAC/C,WAAA;AACA,UAAA,IAAI4K,cAAc,IAAIC,QAAQ,IAAIC,YAAY,EAAE;AAC9C;YACAnN,GAAG,CAAC2B,SAAS,GAAGuL,QAAkB,CAAA;YAClClN,GAAG,CAACoD,QAAQ,CACVb,SAAS,EACTjB,GAAG,GAAGwI,OAAO,GAAGqC,IAAI,GAAGD,EAAE,GAAGa,aAAa,GAAGW,aAAa,EACzDrL,QAAQ,EACRqL,aACF,CAAC,CAAA;AACH,WAAA;UACApL,QAAQ,GAAGO,OAAO,CAAC/D,IAAI,CAAA;UACvBuD,QAAQ,GAAGQ,OAAO,CAAC9H,KAAK,CAAA;AACxBkS,UAAAA,cAAc,GAAGI,iBAAiB,CAAA;AAClCF,UAAAA,YAAY,GAAGI,eAAe,CAAA;AAC9BL,UAAAA,QAAQ,GAAGI,WAAW,CAAA;AACtBnB,UAAAA,IAAI,GAAGqB,WAAW,CAAA;AAClBtB,UAAAA,EAAE,GAAGuB,SAAS,CAAA;AAChB,SAAC,MAAM;UACLpL,QAAQ,IAAIQ,OAAO,CAAChE,WAAW,CAAA;AACjC,SAAA;AACF,OAAA;AACA,MAAA,IAAI0D,SAAS,GAAGX,UAAU,GAAGO,cAAc,GAAGG,QAAQ,CAAA;AACtD,MAAA,IAAI,IAAI,CAACiB,SAAS,KAAK,KAAK,EAAE;AAC5BhB,QAAAA,SAAS,GAAG,IAAI,CAACxH,KAAK,GAAGwH,SAAS,GAAGF,QAAQ,CAAA;AAC/C,OAAA;MACArC,GAAG,CAAC2B,SAAS,GAAG2L,WAAqB,CAAA;MACrC,MAAMI,aAAa,GAAI,IAAI,CAAC9N,QAAQ,GAAG2N,eAAe,GAAI,IAAI,CAAA;AAC9DF,MAAAA,iBAAiB,IACfC,WAAW,IACXC,eAAe,IACfvN,GAAG,CAACoD,QAAQ,CACVb,SAAS,EACTjB,GAAG,GAAGwI,OAAO,GAAGqC,IAAI,GAAGD,EAAE,GAAGa,aAAa,GAAGW,aAAa,EACzDrL,QAAQ,GAAG2C,WAAW,EACtB0I,aACF,CAAC,CAAA;AACHZ,MAAAA,SAAS,IAAI9K,YAAY,CAAA;AAC3B,KAAA;AACA;AACA;AACA,IAAA,IAAI,CAACwB,aAAa,CAACxD,GAAG,CAAC,CAAA;AACzB,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACEkB,EAAAA,mBAAmBA,GAaT;IAAA,IAZR;MACEzB,UAAU,GAAG,IAAI,CAACA,UAAU;MAC5BkO,SAAS,GAAG,IAAI,CAACA,SAAS;MAC1BC,UAAU,GAAG,IAAI,CAACA,UAAU;MAC5BhO,QAAQ,GAAG,IAAI,CAACA,QAAAA;AAMlB,KAAC,GAAAiO,SAAA,CAAAzP,MAAA,GAAAyP,CAAAA,IAAAA,SAAA,CAAApJ,CAAAA,CAAAA,KAAAA,SAAA,GAAAoJ,SAAA,CAAG,CAAA,CAAA,GAAA,EAAE,CAAA;IAAA,IACNlN,YAAsB,GAAAkN,SAAA,CAAAzP,MAAA,GAAAyP,CAAAA,GAAAA,SAAA,MAAApJ,SAAA,CAAA;AAEtB,IAAA,MAAMqJ,gBAAgB,GACpBrO,UAAU,CAACjC,QAAQ,CAAC,GAAG,CAAC,IACxBiC,UAAU,CAACjC,QAAQ,CAAC,GAAG,CAAC,IACxBiC,UAAU,CAACjC,QAAQ,CAAC,GAAG,CAAC,IACxBtC,UAAU,CAAC6S,YAAY,CAACvQ,QAAQ,CAACiC,UAAU,CAACuO,WAAW,EAAE,CAAC,GACtDvO,UAAU,QAAAF,MAAA,CACNE,UAAU,EAAG,IAAA,CAAA,CAAA;IACvB,OAAO,CACLkO,SAAS,EACTC,UAAU,KAAArO,MAAA,CACPoB,YAAY,GAAG,IAAI,CAACyD,eAAe,GAAGxE,QAAQ,EACjDkO,IAAAA,CAAAA,EAAAA,gBAAgB,CACjB,CAAC9E,IAAI,CAAC,GAAG,CAAC,CAAA;AACb,GAAA;;AAEA;AACF;AACA;AACA;EACEiF,MAAMA,CAACjO,GAA6B,EAAE;AACpC,IAAA,IAAI,CAAC,IAAI,CAACkO,OAAO,EAAE;AACjB,MAAA,OAAA;AACF,KAAA;IACA,IACE,IAAI,CAACrT,MAAM,IACX,IAAI,CAACA,MAAM,CAACsT,aAAa,IACzB,CAAC,IAAI,CAACC,KAAK,IACX,CAAC,IAAI,CAACC,UAAU,EAAE,EAClB;AACA,MAAA,OAAA;AACF,KAAA;IACA,IAAI,IAAI,CAAC3B,gBAAgB,EAAE;MACzB,IAAI,CAACxQ,cAAc,EAAE,CAAA;AACvB,KAAA;AACA,IAAA,KAAK,CAAC+R,MAAM,CAACjO,GAAG,CAAC,CAAA;AACnB,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEsO,aAAaA,CAACC,KAAa,EAAY;IACrC,OAAOD,aAAa,CAACC,KAAK,CAAC,CAAA;AAC7B,GAAA;;AAEA;AACF;AACA;AACA;AACA;EACE/R,mBAAmBA,CAAChB,IAAY,EAAiB;IAC/C,MAAMkB,KAAK,GAAGlB,IAAI,CAACgT,KAAK,CAAC,IAAI,CAACC,UAAU,CAAC;AACvClS,MAAAA,QAAQ,GAAG,IAAIkJ,KAAK,CAAW/I,KAAK,CAAC0B,MAAM,CAAC;MAC5CsQ,OAAO,GAAG,CAAC,IAAI,CAAC,CAAA;IAClB,IAAIC,OAAiB,GAAG,EAAE,CAAA;AAC1B,IAAA,KAAK,IAAIzQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxB,KAAK,CAAC0B,MAAM,EAAEF,CAAC,EAAE,EAAE;AACrC3B,MAAAA,QAAQ,CAAC2B,CAAC,CAAC,GAAG,IAAI,CAACoQ,aAAa,CAAC5R,KAAK,CAACwB,CAAC,CAAC,CAAC,CAAA;MAC1CyQ,OAAO,GAAGA,OAAO,CAACpP,MAAM,CAAChD,QAAQ,CAAC2B,CAAC,CAAC,EAAEwQ,OAAO,CAAC,CAAA;AAChD,KAAA;IACAC,OAAO,CAACC,GAAG,EAAE,CAAA;IACb,OAAO;AACL9R,MAAAA,eAAe,EAAEP,QAAQ;AACzBG,MAAAA,KAAK,EAAEA,KAAK;AACZM,MAAAA,YAAY,EAAE2R,OAAO;AACrB/R,MAAAA,aAAa,EAAEL,QAAAA;KAChB,CAAA;AACH,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACEsS,EAAAA,QAAQA,GAG8C;AAAA,IAAA,IAApDC,mBAAwB,GAAAjB,SAAA,CAAAzP,MAAA,GAAA,CAAA,IAAAyP,SAAA,CAAA,CAAA,CAAA,KAAApJ,SAAA,GAAAoJ,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE,CAAA;AAC7B,IAAA,OAAAxS,cAAA,CAAAA,cAAA,CAAA,EAAA,EACK,KAAK,CAACwT,QAAQ,CAAC,CAAC,GAAGE,eAAe,EAAE,GAAGD,mBAAmB,CAAQ,CAAC,CAAA,EAAA,EAAA,EAAA;MACtEhT,MAAM,EAAEkT,aAAa,CAAC,IAAI,CAAClT,MAAM,EAAE,IAAI,CAACN,IAAI,CAAA;KACxC,EAAA,IAAI,CAACQ,IAAI,GAAG;AAAEA,MAAAA,IAAI,EAAE,IAAI,CAACA,IAAI,CAAC6S,QAAQ,EAAC;KAAG,GAAG,EAAE,CAAA,CAAA;AAEvD,GAAA;AAEAlK,EAAAA,GAAGA,CAACsK,GAAiB,EAAEV,KAAW,EAAE;IAClC,MAAM;AAAEW,MAAAA,oBAAAA;KAAsB,GAAG,IAAI,CAAC3T,WAAgC,CAAA;AACtE,IAAA,KAAK,CAACoJ,GAAG,CAACsK,GAAG,EAAEV,KAAK,CAAC,CAAA;IACrB,IAAIY,SAAS,GAAG,KAAK,CAAA;IACrB,IAAIC,YAAY,GAAG,KAAK,CAAA;AACxB,IAAA,IAAI,OAAOH,GAAG,KAAK,QAAQ,EAAE;AAC3B,MAAA,KAAK,MAAMI,IAAI,IAAIJ,GAAG,EAAE;QACtB,IAAII,IAAI,KAAK,MAAM,EAAE;UACnB,IAAI,CAACpT,WAAW,EAAE,CAAA;AACpB,SAAA;QACAkT,SAAS,GAAGA,SAAS,IAAID,oBAAoB,CAAC1R,QAAQ,CAAC6R,IAAI,CAAC,CAAA;AAC5DD,QAAAA,YAAY,GAAGA,YAAY,IAAIC,IAAI,KAAK,MAAM,CAAA;AAChD,OAAA;AACF,KAAC,MAAM;AACLF,MAAAA,SAAS,GAAGD,oBAAoB,CAAC1R,QAAQ,CAACyR,GAAG,CAAC,CAAA;MAC9CG,YAAY,GAAGH,GAAG,KAAK,MAAM,CAAA;AAC/B,KAAA;AACA,IAAA,IAAIG,YAAY,EAAE;MAChB,IAAI,CAACnT,WAAW,EAAE,CAAA;AACpB,KAAA;AACA,IAAA,IAAIkT,SAAS,IAAI,IAAI,CAACpT,WAAW,EAAE;MACjC,IAAI,CAACG,cAAc,EAAE,CAAA;MACrB,IAAI,CAACC,SAAS,EAAE,CAAA;AAClB,KAAA;AACA,IAAA,OAAO,IAAI,CAAA;AACb,GAAA;;AAEA;AACF;AACA;AACA;AACEqD,EAAAA,UAAUA,GAAW;AACnB,IAAA,OAAO,CAAC,CAAA;AACV,GAAA;;AAEA;AACF;AACA;AACA;;AAuCE;AACF;AACA;AACA;AACA;AACA;AACA;AACE,EAAA,aAAa8P,WAAWA,CACtBC,OAAoB,EACpB9T,OAAkB,EAClB+T,QAAmB,EACnB;IACA,MAAMC,gBAAgB,GAAGC,eAAe,CACtCH,OAAO,EACPrU,UAAU,CAACyU,eAAe,EAC1BH,QACF,CAAC,CAAA;IAED,MAAAI,qBAAA,GAAAvU,cAAA,CAAAA,cAAA,CAUSI,EAAAA,EAAAA,OAAO,GAAKgU,gBAAgB,CAAA;AAV/B,MAAA;AACJI,QAAAA,UAAU,GAAG9J,IAAkD;AAC/D+J,QAAAA,cAAc,GAAG,EAAE;AACnBC,QAAAA,EAAE,GAAG,CAAC;AACN7D,QAAAA,EAAE,GAAG,CAAC;AACN5K,QAAAA,GAAG,GAAG,CAAC;AACPxC,QAAAA,IAAI,GAAG,CAAC;AACRc,QAAAA,QAAQ,GAAGoQ,qBAAqB;AAChCpI,QAAAA,WAAW,GAAG,CAAA;AAEhB,OAAC,GAAAgI,qBAAA;AADIK,MAAAA,aAAa,GAAAC,wBAAA,CAAAN,qBAAA,EAAAO,SAAA,CAAA,CAAA;AAGlB,IAAA,MAAMC,WAAW,GAAGC,WAAW,CAACd,OAAO,CAACa,WAAW,IAAI,EAAE,CAAC,CAACE,IAAI,EAAE,CAAA;;AAEjE;AACA;;AAEA,IAAA,MAAM9U,IAAI,GAAG,IAAI,IAAI,CAAC4U,WAAW,EAAA/U,cAAA,CAAA;QAC7ByD,IAAI,EAAEA,IAAI,GAAGiR,EAAE;QACfzO,GAAG,EAAEA,GAAG,GAAG4K,EAAE;AACbqE,QAAAA,SAAS,EAAET,cAAc,CAACtS,QAAQ,CAAC,WAAW,CAAC;AAC/CgT,QAAAA,QAAQ,EAAEV,cAAc,CAACtS,QAAQ,CAAC,UAAU,CAAC;AAC7CiT,QAAAA,WAAW,EAAEX,cAAc,CAACtS,QAAQ,CAAC,cAAc,CAAC;AACpD;AACAoK,QAAAA,WAAW,EAAE,CAAC;AACdhI,QAAAA,QAAAA;OACGqQ,EAAAA,aAAa,CACjB,CAAC;MACFS,qBAAqB,GAAGlV,IAAI,CAACmV,eAAe,EAAE,GAAGnV,IAAI,CAACR,MAAM;AAC5D4V,MAAAA,cAAc,GACZ,CAACpV,IAAI,CAACR,MAAM,GAAGQ,IAAI,CAACoM,WAAW,IAAIpM,IAAI,CAAC8L,UAAU,GAAG9L,IAAI,CAACR,MAAM;MAClE6V,UAAU,GAAGD,cAAc,GAAGF,qBAAqB;AACnDI,MAAAA,UAAU,GAAGtV,IAAI,CAACmV,eAAe,EAAE,GAAGE,UAAU,CAAA;IAElD,IAAIE,IAAI,GAAG,CAAC,CAAA;AACZ;AACJ;AACA;AACA;AACA;IACI,IAAIlB,UAAU,KAAK/O,MAAM,EAAE;AACzBiQ,MAAAA,IAAI,GAAGvV,IAAI,CAACwV,cAAc,EAAE,GAAG,CAAC,CAAA;AAClC,KAAA;IACA,IAAInB,UAAU,KAAKvK,KAAK,EAAE;AACxByL,MAAAA,IAAI,GAAGvV,IAAI,CAACwV,cAAc,EAAE,CAAA;AAC9B,KAAA;IACAxV,IAAI,CAACmJ,GAAG,CAAC;AACP7F,MAAAA,IAAI,EAAEtD,IAAI,CAACsD,IAAI,GAAGiS,IAAI;MACtBzP,GAAG,EACD9F,IAAI,CAAC8F,GAAG,GACR,CAACwP,UAAU,GAAGtV,IAAI,CAACoE,QAAQ,IAAI,IAAI,GAAGpE,IAAI,CAAC6H,iBAAiB,CAAC,IAC3D7H,IAAI,CAAC8L,UAAU;AACnBM,MAAAA,WAAAA;AACF,KAAC,CAAC,CAAA;AACF,IAAA,OAAOpM,IAAI,CAAA;AACb,GAAA;;AAEA;;AAEA;AACF;AACA;AACA;AACA;EACE,OAAOyV,UAAUA,CAGfC,MAAS,EAAE;IACX,OAAO,IAAI,CAACC,WAAW,CAAA9V,cAAA,CAAAA,cAAA,KAEhB6V,MAAM,CAAA,EAAA,EAAA,EAAA;AACTpV,MAAAA,MAAM,EAAEsV,eAAe,CAACF,MAAM,CAACpV,MAAM,IAAI,EAAE,EAAEoV,MAAM,CAAC1V,IAAI,CAAA;KAE1D,CAAA,EAAA;AACE6V,MAAAA,UAAU,EAAE,MAAA;AACd,KACF,CAAC,CAAA;AACH,GAAA;AACF,CAAA;AAtyDE;AACF;AACA;AACA;AACA;AAJE3V,eAAA,CARWR,UAAU,EAAA,sBAAA,EAamBgU,oBAAoB,CAAA,CAAA;AAAAxT,eAAA,CAbjDR,UAAU,EA8SI,iBAAA,EAAA,CAAC,GAAGoW,eAAe,EAAE,GAAGvC,eAAe,CAAC,CAAA,CAAA;AAAArT,eAAA,CA9StDR,UAAU,EAAA,aAAA,EAgTAqW,iBAAiB,CAAA,CAAA;AAAA7V,eAAA,CAhT3BR,UAAU,EAAA,MAAA,EAkTP,MAAM,CAAA,CAAA;AAAAQ,eAAA,CAlTTR,UAAU,EAwqDC,cAAA,EAAA,CACpB,OAAO,EACP,YAAY,EACZ,WAAW,EACX,SAAS,EACT,SAAS,EACT,WAAW,EACX,UAAU,EACV,eAAe,EACf,cAAc,EACd,YAAY,EACZ,MAAM,EACN,OAAO,EACP,UAAU,CACX,CAAA,CAAA;AAED;AAEA;AACF;AACA;AACA;AACA;AACA;AALEQ,eAAA,CA1rDWR,UAAU,EAgsDIsW,iBAAAA,EAAAA,iBAAiB,CAACjS,MAAM,CAC/C,GAAG,EACH,GAAG,EACH,IAAI,EACJ,IAAI,EACJ,aAAa,EACb,YAAY,EACZ,aAAa,EACb,WAAW,EACX,gBAAgB,EAChB,iBAAiB,EACjB,aACF,CAAC,CAAA,CAAA;AAoGHkS,WAAW,CAACvW,UAAU,EAAE,CAACwW,kBAAkB,CAAC,CAAC,CAAA;AAC7CC,aAAa,CAACC,QAAQ,CAAC1W,UAAU,CAAC,CAAA;AAClCyW,aAAa,CAACE,WAAW,CAAC3W,UAAU,CAAC;;;;"}